
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Haskell Examples</title>
</head>

<script src="https://cdn.tailwindcss.com"></script>

<style>

.block {
   margin: 20px;
   padding: 8px;
   background-color:grey;
   transition: 0.5s;
}

.block:hover {
        margin: -2px;
        transition: 0.5s;
    }

.navbar {
        overflow: hidden;
        background-color: #333;
        position: fixed;
        /* Set the navbar to fixed position */
        top: 0;
        /* Position the navbar at the top of the page */
        width: 100%;
        /* Full width */
    }
    /* Links inside the navbar */
    
    .navbar a {
        float: left;
        display: block;
        color: #f2f2f2;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
    }
    /* Change background on mouse-over */
    
    .navbar a:hover {
        background: #ddd;
        color: black;
    }
    
</style>

<body>

        <div class="navbar">
            <ul class="navigation">
         
                <li class="nav-item">
                    <a href="#01-introduction">01-introduction</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#02-starting-out">02-starting-out</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#03-types-and-typeclasses">03-types-and-typeclasses</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#04-syntax-in-functions">04-syntax-in-functions</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#05-recursion">05-recursion</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#06-higher-order-functions">06-higher-order-functions</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#07-modules">07-modules</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#08-making-our-own-types-and-typeclasses">08-making-our-own-types-and-typeclasses</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#09-input-and-output">09-input-and-output</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#10-functionally-solving-problems">10-functionally-solving-problems</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#11-functors-applicative-functors-and-monoids">11-functors-applicative-functors-and-monoids</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#12-a-fistful-of-monads">12-a-fistful-of-monads</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#13-for-a-few-monads-more">13-for-a-few-monads-more</a>
                </li>
                 
                <li class="nav-item">
                    <a href="#14-zippers">14-zippers</a>
                </li>
                </ul>
        </div>



<h1 id="01-introduction"class="text-center font-bold text-4xl my-40">01-introduction</h1>
  <div class="flex flex-row flex-wrap">
</div>

<h1 id="02-starting-out"class="text-center font-bold text-4xl my-40">02-starting-out</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Prelude>
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 2 + 15
17
ghci> 49 * 100
4900
ghci> 1892 - 1472
420
ghci> 5 / 2
2.5
ghci>
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (50 * 100) - 4999
1
ghci> 50 * 100 - 4999
1
ghci> 50 * (100 - 4999)
-244950
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> True && False
False
ghci> True && True
True
ghci> False || True
True
ghci> not False
True
ghci> not (True && True)
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 5 == 5
True
ghci> 1 == 0
False
ghci> 5 /= 5
False
ghci> 5 /= 4
True
ghci> "hello" == "hello"
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
No instance for (Num [Char])
arising from a use of `+' at <interactive>:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> succ 8
9
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> min 9 10
9
ghci> min 3.4 3.2
3.2
ghci> max 100 101
101
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> succ 9 + max 5 4 + 1
16
ghci> (succ 9) + (max 5 4) + 1
16
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
doubleMe x = x + x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.
ghci> doubleMe 9
18
ghci> doubleMe 8.3
16.6
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
doubleUs x y = x*2 + y*2
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> doubleUs 4 9
26
ghci> doubleUs 2.3 34.2
73.0
ghci> doubleUs 28 88 + doubleMe 123
478
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
doubleUs x y = doubleMe x + doubleMe y
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
doubleSmallNumber x = if x > 100
                        then x
                        else x*2
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
conanO'Brien = "It's a-me, Conan O'Brien!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let lostNumbers = [4,8,15,16,23,42]
ghci> lostNumbers
[4,8,15,16,23,42]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci> "hello" ++ " " ++ "world"
"hello world"
ghci> ['w','o'] ++ ['o','t']
"woot"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 'A':" SMALL CAT"
"A SMALL CAT"
ghci> 5:[1,2,3,4,5]
[5,1,2,3,4,5]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> "Steve Buscemi" !! 6
'B'
ghci> [9.4,33.2,96.2,11.2,23.25] !! 1
33.2
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci> [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b !! 2
[1,2,2,3,4]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [3,2,1] > [2,1,0]
True
ghci> [3,2,1] > [2,10,100]
True
ghci> [3,4,2] > [3,4]
True
ghci> [3,4,2] > [2,4]
True
ghci> [3,4,2] == [3,4,2]
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> head [5,4,3,2,1]
5
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> tail [5,4,3,2,1]
[4,3,2,1]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> last [5,4,3,2,1]
1
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> init [5,4,3,2,1]
[5,4,3,2]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> head []
*** Exception: Prelude.head: empty list
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> length [5,4,3,2,1]
5
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> null [1,2,3]
False
ghci> null []
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> reverse [5,4,3,2,1]
[1,2,3,4,5]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> take 3 [5,4,3,2,1]
[5,4,3]
ghci> take 1 [3,9,3]
[3]
ghci> take 5 [1,2]
[1,2]
ghci> take 0 [6,6,6]
[]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci> drop 0 [1,2,3,4]
[1,2,3,4]
ghci> drop 100 [1,2,3,4]
[]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> minimum [8,4,2,1,5,6]
1
ghci> maximum [1,9,2,3,4]
9
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sum [5,2,1,6,3,2,5,7]
31
ghci> product [6,2,1,2]
24
ghci> product [1,2,5,6,7,9,2,0]
0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 4 `elem` [3,4,5,6]
True
ghci> 10 `elem` [3,4,5,6]
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci> ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci> ['K'..'Z']
"KLMNOPQRSTUVWXYZ"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci> [3,6..20]
[3,6,9,12,15,18]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci> take 12 (cycle "LOL ")
"LOL LOL LOL "
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [ x | x <- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
[16,20,22,40,50,55,80,100,110]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
[55,80,100,110]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let nouns = ["hobo","frog","pope"]
ghci> let adjectives = ["lazy","grouchy","scheming"]
ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
length' xs = sum [1 | _ <- xs]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci> removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci> [ [ x | x <- xs, even x ] | xs <- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fst (8,11)
8
ghci> fst ("Wow", False)
"Wow"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> snd (8,11)
11
ghci> snd ("Wow", False)
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci> zip [1 .. 5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci> rightTriangles'
[(6,8,10)]
		 </code>
 	</pre> 
</div>

</div>

<h1 id="03-types-and-typeclasses"class="text-center font-bold text-4xl my-40">03-types-and-typeclasses</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t 'a'
'a' :: Char
ghci> :t True
True :: Bool
ghci> :t "HELLO!"
"HELLO!" :: [Char]
ghci> :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci> :t 4 == 5
4 == 5 :: Bool
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
removeNonUppercase :: [Char] -> [Char]
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
factorial :: Integer -> Integer
factorial n = product [1..n]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> factorial 50
30414093201713378043612608166064768844377641568960512000000000000
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
circumference :: Float -> Float
circumference r = 2 * pi * r
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> circumference 4.0
25.132742
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
circumference' :: Double -> Double
circumference' r = 2 * pi * r
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> circumference' 4.0
25.132741228718345
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t head
head :: [a] -> a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t fst
fst :: (a, b) -> a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t (==)
(==) :: (Eq a) => a -> a -> Bool
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 5 == 5
True
ghci> 5 /= 5
False
ghci> 'a' == 'a'
True
ghci> "Ho Ho" == "Ho Ho"
True
ghci> 3.432 == 3.432
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t (>)
(>) :: (Ord a) => a -> a -> Bool
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> "Abrakadabra" < "Zebra"
True
ghci> "Abrakadabra" `compare` "Zebra"
LT
ghci> 5 >= 2
True
ghci> 5 `compare` 3
GT
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> show 3
"3"
ghci> show 5.334
"5.334"
ghci> show True
"True"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> read "True" || False
True
ghci> read "8.2" + 3.8
12.0
ghci> read "5" - 2
3
ghci> read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> read "4"
<interactive>:1:0:
    Ambiguous type variable `a' in the constraint:
      `Read a' arising from a use of `read' at <interactive>:1:0-7
    Probable fix: add a type signature that fixes these type variable(s)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t read
read :: (Read a) => String -> a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> read "5" :: Int
5
ghci> read "5" :: Float
5.0
ghci> (read "5" :: Float) * 4
20.0
ghci> read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci> read "(3, 'a')" :: (Int, Char)
(3, 'a')
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> ['a'..'e']
"abcde"
ghci> [LT .. GT]
[LT,EQ,GT]
ghci> [3 .. 5]
[3,4,5]
ghci> succ 'B'
'C'
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> minBound :: Int
-2147483648
ghci> maxBound :: Char
'\1114111'
ghci> maxBound :: Bool
True
ghci> minBound :: Bool
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t 20
20 :: (Num t) => t
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 20 :: Int
20
ghci> 20 :: Integer
20
ghci> 20 :: Float
20.0
ghci> 20 :: Double
20.0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t (*)
(*) :: (Num a) => a -> a -> a
		 </code>
 	</pre> 
</div>

</div>

<h1 id="04-syntax-in-functions"class="text-center font-bold text-4xl my-40">04-syntax-in-functions</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
lucky :: (Integral a) => a -> String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, you're out of luck, pal!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
sayMe :: (Integral a) => a -> String
sayMe 1 = "One!"
sayMe 2 = "Two!"
sayMe 3 = "Three!"
sayMe 4 = "Four!"
sayMe 5 = "Five!"
sayMe x = "Not between 1 and 5"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
factorial :: (Integral a) => a -> a
factorial 0 = 1
factorial n = n * factorial (n - 1)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
charName :: Char -> String
charName 'a' = "Albert"
charName 'b' = "Broseph"
charName 'c' = "Cecil"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> charName 'a'
"Albert"
ghci> charName 'b'
"Broseph"
ghci> charName 'h'
"*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
addVectors a b = (fst a + fst b, snd a + snd b)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
first :: (a, b, c) -> a
first (x, _, _) = x

second :: (a, b, c) -> b
second (_, y, _) = y

third :: (a, b, c) -> c
third (_, _, z) = z
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
ghci> [a+b | (a,b) <- xs]
[4,7,6,8,11,4]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
head' :: [a] -> a
head' [] = error "Can't call head on an empty list, dummy!"
head' (x:_) = x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> head' [4,5,6]
4
ghci> head' "Hello"
'H'
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
tell :: (Show a) => [a] -> String
tell [] = "The list is empty"
tell (x:[]) = "The list has one element: " ++ show x
tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y
tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
length' :: (Num b) => [a] -> b
length' [] = 0
length' (_:xs) = 1 + length' xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
sum' :: (Num a) => [a] -> a
sum' [] = 0
sum' (x:xs) = x + sum' xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
capital :: String -> String
capital "" = "Empty string, whoops!"
capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> capital "Dracula"
"The first letter of Dracula is D"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
bmiTell :: (RealFloat a) => a -> String
bmiTell bmi
    | bmi <= 18.5 = "You're underweight, you emo, you!"
    | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise   = "You're a whale, congratulations!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
bmiTell :: (RealFloat a) => a -> a -> String
bmiTell weight height
    | weight / height ^ 2 <= 18.5 = "You're underweight, you emo, you!"
    | weight / height ^ 2 <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | weight / height ^ 2 <= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise                 = "You're a whale, congratulations!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> bmiTell 85 1.90
"You're supposedly normal. Pffft, I bet you're ugly!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
max' :: (Ord a) => a -> a -> a
max' a b
    | a > b     = a
    | otherwise = b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
max' :: (Ord a) => a -> a -> a
max' a b | a > b = a | otherwise = b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
myCompare :: (Ord a) => a -> a -> Ordering
a `myCompare` b
    | a > b     = GT
    | a == b    = EQ
    | otherwise = LT
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 3 `myCompare` 2
GT
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
bmiTell :: (RealFloat a) => a -> a -> String
bmiTell weight height
    | weight / height ^ 2 <= 18.5 = "You're underweight, you emo, you!"
    | weight / height ^ 2 <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | weight / height ^ 2 <= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise                   = "You're a whale, congratulations!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
bmiTell :: (RealFloat a) => a -> a -> String
bmiTell weight height
    | bmi <= 18.5 = "You're underweight, you emo, you!"
    | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise   = "You're a whale, congratulations!"
    where bmi = weight / height ^ 2
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
bmiTell :: (RealFloat a) => a -> a -> String
bmiTell weight height
    | bmi <= skinny = "You're underweight, you emo, you!"
    | bmi <= normal = "You're supposedly normal. Pffft, I bet you're ugly!"
    | bmi <= fat    = "You're fat! Lose some weight, fatty!"
    | otherwise     = "You're a whale, congratulations!"
    where bmi = weight / height ^ 2
          skinny = 18.5
          normal = 25.0
          fat = 30.0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
    ...
    where bmi = weight / height ^ 2
          (skinny, normal, fat) = (18.5, 25.0, 30.0)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
initials :: String -> String -> String
initials firstname lastname = [f] ++ ". " ++ [l] ++ "."
    where (f:_) = firstname
          (l:_) = lastname
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
calcBmis :: (RealFloat a) => [(a, a)] -> [a]
calcBmis xs = [bmi w h | (w, h) <- xs]
    where bmi weight height = weight / height ^ 2
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
cylinder :: (RealFloat a) => a -> a -> a
cylinder r h =
    let sideArea = 2 * pi * r * h
        topArea = pi * r ^2
    in  sideArea + 2 * topArea
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [if 5 > 3 then "Woo" else "Boo", if 'a' > 'b' then "Foo" else "Bar"]
["Woo", "Bar"]
ghci> 4 * (if 10 > 5 then 10 else 0) + 2
42
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 4 * (let a = 9 in a + 1) + 2
42
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [let square x = x * x in (square 5, square 3, square 2)]
[(25,9,4)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
(6000000,"Hey there!")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (let (a,b,c) = (1,2,3) in a+b+c) * 100
600
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
calcBmis :: (RealFloat a) => [(a, a)] -> [a]
calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
calcBmis :: (RealFloat a) => [(a, a)] -> [a]
calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let zoot x y z = x * y + z
ghci> zoot 3 9 2
29
ghci> let boot x y z = x * y + z in boot 3 4 2
14
ghci> boot
<interactive>:1:0: Not in scope: `boot'
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
head' :: [a] -> a
head' [] = error "No head for empty lists!"
head' (x:_) = x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
head' :: [a] -> a
head' xs = case xs of [] -> error "No head for empty lists!"
                      (x:_) -> x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
case expression of pattern -> result
                   pattern -> result
                   pattern -> result
                   ...
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
describeList :: [a] -> String
describeList xs = "The list is " ++ case xs of [] -> "empty."
                                               [x] -> "a singleton list."
                                               xs -> "a longer list."
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
describeList :: [a] -> String
describeList xs = "The list is " ++ what xs
    where what [] = "empty."
          what [x] = "a singleton list."
          what xs = "a longer list."
		 </code>
 	</pre> 
</div>

</div>

<h1 id="05-recursion"class="text-center font-bold text-4xl my-40">05-recursion</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
maximum' :: (Ord a) => [a] -> a
maximum' [] = error "maximum of empty list"
maximum' [x] = x
maximum' (x:xs)
    | x > maxTail = x
    | otherwise = maxTail
    where maxTail = maximum' xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
maximum' :: (Ord a) => [a] -> a
maximum' [] = error "maximum of empty list"
maximum' [x] = x
maximum' (x:xs) = max x (maximum' xs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
replicate' :: (Num i, Ord i) => i -> a -> [a]
replicate' n x
    | n <= 0    = []
    | otherwise = x:replicate' (n-1) x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
take' :: (Num i, Ord i) => i -> [a] -> [a]
take' n _
    | n <= 0   = []
take' _ []     = []
take' n (x:xs) = x : take' (n-1) xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
reverse' :: [a] -> [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
repeat' :: a -> [a]
repeat' x = x:repeat' x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
zip' :: [a] -> [b] -> [(a,b)]
zip' _ [] = []
zip' [] _ = []
zip' (x:xs) (y:ys) = (x,y):zip' xs ys
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
elem' :: (Eq a) => a -> [a] -> Bool
elem' a [] = False
elem' a (x:xs)
    | a == x    = True
    | otherwise = a `elem'` xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
    let smallerSorted = quicksort [a | a <- xs, a <= x]
        biggerSorted = quicksort [a | a <- xs, a > x]
    in  smallerSorted ++ [x] ++ biggerSorted
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9]
[1,2,2,3,3,4,4,5,6,7,8,9,10]
ghci> quicksort "the quick brown fox jumps over the lazy dog"
"        abcdeeefghhijklmnoooopqrrsttuuvwxyz"
		 </code>
 	</pre> 
</div>

</div>

<h1 id="06-higher-order-functions"class="text-center font-bold text-4xl my-40">06-higher-order-functions</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> max 4 5
5
ghci> (max 4) 5
5
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
multThree :: (Num a) => a -> a -> a -> a
multThree x y z = x * y * z
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let multTwoWithNine = multThree 9
ghci> multTwoWithNine 2 3
54
ghci> let multWithEighteen = multTwoWithNine 2
ghci> multWithEighteen 10
180
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
compareWithHundred :: (Num a, Ord a) => a -> Ordering
compareWithHundred x = compare 100 x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
compareWithHundred :: (Num a, Ord a) => a -> Ordering
compareWithHundred = compare 100
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
divideByTen :: (Floating a) => a -> a
divideByTen = (/10)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
isUpperAlphanum :: Char -> Bool
isUpperAlphanum = (`elem` ['A'..'Z'])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> multThree 3 4
<interactive>:1:0:
    No instance for (Show (t -> t))
      arising from a use of `print' at <interactive>:1:0-12
    Possible fix: add an instance declaration for (Show (t -> t))
    In the expression: print it
    In a 'do' expression: print it
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> applyTwice (+3) 10
16
ghci> applyTwice (++ " HAHA") "HEY"
"HEY HAHA HAHA"
ghci> applyTwice ("HAHA " ++) "HEY"
"HAHA HAHA HEY"
ghci> applyTwice (multThree 2 2) 9
144
ghci> applyTwice (3:) [1]
[3,3,1]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> zipWith' (+) [4,2,5,6] [2,6,2,3]
[6,8,7,9]
ghci> zipWith' max [6,3,2,1] [7,3,1,5]
[7,3,2,5]
ghci> zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"]
["foo fighters","bar hoppers","baz aldrin"]
ghci> zipWith' (*) (replicate 5 2) [1..]
[2,4,6,8,10]
ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
[[3,4,6],[9,20,30],[10,12,12]]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
flip' :: (a -> b -> c) -> (b -> a -> c)
flip' f = g
    where g x y = f y x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
flip' :: (a -> b -> c) -> b -> a -> c
flip' f y x = f x y
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> flip' zip [1,2,3,4,5] "hello"
[('h',1),('e',2),('l',3),('l',4),('o',5)]
ghci> zipWith (flip' div) [2,2..] [10,8,6,4,2]
[5,4,3,2,1]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map (+3) [1,5,3,1,6]
[4,8,6,4,9]
ghci> map (++ "!") ["BIFF", "BANG", "POW"]
["BIFF!","BANG!","POW!"]
ghci> map (replicate 3) [3..6]
[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]
ghci> map (map (^2)) [[1,2],[3,4,5,6],[7,8]]
[[1,4],[9,16,25,36],[49,64]]
ghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]
[1,3,6,2,2]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs)
    | p x       = x : filter p xs
    | otherwise = filter p xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> filter (>3) [1,5,3,2,1,6,4,3,2,1]
[5,6,4]
ghci> filter (==3) [1,2,3,4,5]
[3]
ghci> filter even [1..10]
[2,4,6,8,10]
ghci> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
[[1,2,3],[3,4,5],[2,2]]
ghci> filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"
"uagameasadifeent"
ghci> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
"GAYBALLS"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
    let smallerSorted = quicksort (filter (<=x) xs)
        biggerSorted = quicksort (filter (>x) xs)
    in  smallerSorted ++ [x] ++ biggerSorted
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
largestDivisible :: (Integral a) => a
largestDivisible = head (filter p [100000,99999..])
    where p x = x `mod` 3829 == 0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..])))
166650
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])
166650
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
chain :: (Integral a) => a -> [a]
chain 1 = [1]
chain n
    | even n =  n:chain (n `div` 2)
    | odd n  =  n:chain (n*3 + 1)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> chain 10
[10,5,16,8,4,2,1]
ghci> chain 1
[1]
ghci> chain 30
[30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
numLongChains :: Int
numLongChains = length (filter isLong (map chain [1..100]))
    where isLong xs = length xs > 15
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let listOfFuns = map (*) [0..]
ghci> (listOfFuns !! 4) 5
20
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
numLongChains :: Int
numLongChains = length (filter (\xs -> length xs > 15) (map chain [1..100]))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]
[153.0,61.5,31.0,15.75,6.6]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]
[3,8,9,8,7]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
addThree :: (Num a) => a -> a -> a -> a
addThree x y z = x + y + z
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
addThree :: (Num a) => a -> a -> a -> a
addThree = \x -> \y -> \z -> x + y + z
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
flip' :: (a -> b -> c) -> b -> a -> c
flip' f = \x y -> f y x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
sum' :: (Num a) => [a] -> a
sum' xs = foldl (\acc x -> acc + x) 0 xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sum' [3,5,2,1]
11
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
sum' :: (Num a) => [a] -> a
sum' = foldl (+) 0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
elem' :: (Eq a) => a -> [a] -> Bool
elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldr (\x acc -> f x : acc) [] xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
maximum' :: (Ord a) => [a] -> a
maximum' = foldr1 (\x acc -> if x > acc then x else acc)

reverse' :: [a] -> [a]
reverse' = foldl (\acc x -> x : acc) []

product' :: (Num a) => [a] -> a
product' = foldr1 (*)

filter' :: (a -> Bool) -> [a] -> [a]
filter' p = foldr (\x acc -> if p x then x : acc else acc) []

head' :: [a] -> a
head' = foldr1 (\x _ -> x)

last' :: [a] -> a
last' = foldl1 (\_ x -> x)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> scanl (+) 0 [3,5,2,1]
[0,3,8,10,11]
ghci> scanr (+) 0 [3,5,2,1]
[11,8,3,1,0]
ghci> scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]
[3,4,5,5,7,9,9,9]
ghci> scanl (flip (:)) [] [3,2,1]
[[],[3],[2,3],[1,2,3]]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
sqrtSums :: Int
sqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sqrtSums
131
ghci> sum (map sqrt [1..131])
1005.0942035344083
ghci> sum (map sqrt [1..130])
993.6486803921487
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
($) :: (a -> b) -> a -> b
f $ x = f x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map ($ 3) [(4+), (10*), (^2), sqrt]
[7.0,30.0,9.0,1.7320508075688772]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map (\xs -> negate (sum (tail xs))) [[1..5],[3..6],[1..7]]
[-14,-15,-27]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map (negate . sum . tail) [[1..5],[3..6],[1..7]]
[-14,-15,-27]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
sum' :: (Num a) => [a] -> a
sum' xs = foldl (+) 0 xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fn x = ceiling (negate (tan (cos (max 50 x))))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fn = ceiling . negate . tan . cos . max 50
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
oddSquareSum :: Integer
oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..])))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
oddSquareSum :: Integer
oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
oddSquareSum :: Integer
oddSquareSum =
    let oddSquares = filter odd $ map (^2) [1..]
        belowLimit = takeWhile (<10000) oddSquares
    in  sum belowLimit
		 </code>
 	</pre> 
</div>

</div>

<h1 id="07-modules"class="text-center font-bold text-4xl my-40">07-modules</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List

numUniques :: (Eq a) => [a] -> Int
numUniques = length . nub
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :m + Data.List
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :m + Data.List Data.Map Data.Set
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List (nub, sort)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List hiding (nub)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import qualified Data.Map
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import qualified Data.Map as M
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> intersperse '.' "MONKEY"
"M.O.N.K.E.Y"
ghci> intersperse 0 [1,2,3,4,5,6]
[1,0,2,0,3,0,4,0,5,0,6]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> intercalate " " ["hey","there","guys"]
"hey there guys"
ghci> intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]]
[1,2,3,0,0,0,4,5,6,0,0,0,7,8,9]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> transpose [[1,2,3],[4,5,6],[7,8,9]]
[[1,4,7],[2,5,8],[3,6,9]]
ghci> transpose ["hey","there","guys"]
["htg","ehu","yey","rs","e"]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
[18,8,6,17]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> concat ["foo","bar","car"]
"foobarcar"
ghci> concat [[3,4,5],[2,3,4],[2,1,1]]
[3,4,5,2,3,4,2,1,1]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> concatMap (replicate 4) [1..3]
[1,1,1,1,2,2,2,2,3,3,3,3]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> and $ map (>4) [5,6,7,8]
True
ghci> and $ map (==4) [4,4,4,3,4]
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> or $ map (==4) [2,3,4,5,6,1]
True
ghci> or $ map (>4) [1,2,3]
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> any (==4) [2,3,5,6,1,4]
True
ghci> all (>4) [6,9,10]
True
ghci> all (`elem` ['A'..'Z']) "HEYGUYSwhatsup"
False
ghci> any (`elem` ['A'..'Z']) "HEYGUYSwhatsup"
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> take 10 $ iterate (*2) 1
[1,2,4,8,16,32,64,128,256,512]
ghci> take 3 $ iterate (++ "haha") "haha"
["haha","hahahaha","hahahahahaha"]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> splitAt 3 "heyman"
("hey","man")
ghci> splitAt 100 "heyman"
("heyman","")
ghci> splitAt (-3) "heyman"
("","heyman")
ghci> let (a,b) = splitAt 3 "foobar" in b ++ a
"barfoo"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]
[6,5,4]
ghci> takeWhile (/=' ') "This is a sentence"
"This"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sum $ takeWhile (<10000) $ map (^3) [1..]
53361
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> dropWhile (/=' ') "This is a sentence"
" is a sentence"
ghci> dropWhile (<3) [1,2,2,2,3,4,5,4,3,2,1]
[3,4,5,4,3,2,1]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let stock = [(994.4,2008,9,1),(995.2,2008,9,2),(999.2,2008,9,3),(1001.4,2008,9,4),(998.3,2008,9,5)]
ghci> head (dropWhile (\(val,y,m,d) -> val < 1000) stock)
(1001.4,2008,9,4)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let (fw, rest) = span (/=' ') "This is a sentence" in "First word: " ++ fw ++ ", the rest:" ++ rest
"First word: This, the rest: is a sentence"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> break (==4) [1,2,3,4,5,6,7]
([1,2,3],[4,5,6,7])
ghci> span (/=4) [1,2,3,4,5,6,7]
([1,2,3],[4,5,6,7])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sort [8,5,3,2,1,6,4,2]
[1,2,2,3,4,5,6,8]
ghci> sort "This will be sorted soon"
"    Tbdeehiillnooorssstw"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> inits "w00t"
["","w","w0","w00","w00t"]
ghci> tails "w00t"
["w00t","00t","0t","t",""]
ghci> let w = "w00t" in zip (inits w) (tails w)
[("","w00t"),("w","00t"),("w0","0t"),("w00","t"),("w00t","")]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
search :: (Eq a) => [a] -> [a] -> Bool
search needle haystack =
    let nlen = length needle
    in  foldl (\acc x -> if take nlen x == needle then True else acc) False (tails haystack)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> "cat" `isInfixOf` "im a cat burglar"
True
ghci> "Cat" `isInfixOf` "im a cat burglar"
False
ghci> "cats" `isInfixOf` "im a cat burglar"
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> "hey" `isPrefixOf` "hey there!"
True
ghci> "hey" `isPrefixOf` "oh hey there!"
False
ghci> "there!" `isSuffixOf` "oh hey there!"
True
ghci> "there!" `isSuffixOf` "oh hey there"
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> partition (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"
("BOBMORGAN","sidneyeddy")
ghci> partition (>3) [1,3,5,6,3,2,1,0,3,7]
([5,6,7],[1,3,3,2,1,0,3])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> span (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"
("BOB","sidneyMORGANeddy")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> find (>4) [1,2,3,4,5,6]
Just 5
ghci> find (>9) [1,2,3,4,5,6]
Nothing
ghci> :t find
find :: (a -> Bool) -> [a] -> Maybe a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t elemIndex
elemIndex :: (Eq a) => a -> [a] -> Maybe Int
ghci> 4 `elemIndex` [1,2,3,4,5,6]
Just 3
ghci> 10 `elemIndex` [1,2,3,4,5,6]
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> ' ' `elemIndices` "Where are the spaces?"
[5,9,13]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> findIndex (==4) [5,3,2,1,6,4]
Just 5
ghci> findIndex (==7) [5,3,2,1,6,4]
Nothing
ghci> findIndices (`elem` ['A'..'Z']) "Where Are The Caps?"
[0,6,10,14]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> zipWith3 (\x y z -> x + y + z) [1,2,3] [4,5,2,2] [2,2,3]
[7,9,8]
ghci> zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]
[(2,2,5,2),(3,2,5,2),(3,2,3,2)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> lines "first line\nsecond line\nthird line"
["first line","second line","third line"]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> unlines ["first line", "second line", "third line"]
"first line\nsecond line\nthird line\n"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> words "hey these are the words in this sentence"
["hey","these","are","the","words","in","this","sentence"]
ghci> words "hey these           are    the words in this\nsentence"
["hey","these","are","the","words","in","this","sentence"]
ghci> unwords ["hey","there","mate"]
"hey there mate"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> nub [1,2,3,4,3,2,1,2,3,4,3,2,1]
[1,2,3,4]
ghci> nub "Lots of words and stuff"
"Lots fwrdanu"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> delete 'h' "hey there ghang!"
"ey there ghang!"
ghci> delete 'h' . delete 'h' $ "hey there ghang!"
"ey tere ghang!"
ghci> delete 'h' . delete 'h' . delete 'h' $ "hey there ghang!"
"ey tere gang!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [1..10] \\ [2,5,9]
[1,3,4,6,7,8,10]
ghci> "Im a big baby" \\ "big"
"Im a  baby"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> "hey man" `union` "man what's up"
"hey manwt'sup"
ghci> [1..7] `union` [5..10]
[1,2,3,4,5,6,7,8,9,10]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [1..7] `intersect` [5..10]
[5,6,7]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> insert 4 [3,5,1,2,8,2]
[3,4,5,1,2,8,2]
ghci> insert 4 [1,3,4,4,1]
[1,3,4,4,4,1]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> insert 4 [1,2,3,5,6,7]
[1,2,3,4,5,6,7]
ghci> insert 'g' $ ['a'..'f'] ++ ['h'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci> insert 3 [1,2,4,3,2,1]
[1,2,3,4,3,2,1]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3]
ghci> groupBy (\x y -> (x > 0) == (y > 0)) values
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
f `on` g = \x y -> f (g x) (g y)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> groupBy ((==) `on` (> 0)) values
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]]
ghci> sortBy (compare `on` length) xs
[[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> all isAlphaNum "bobby283"
True
ghci> all isAlphaNum "eddy the fish!"
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> words "hey guys its me"
["hey","guys","its","me"]
ghci> groupBy ((==) `on` isSpace) "hey guys its me"
["hey"," ","guys"," ","its"," ","me"]
ghci>
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"
["hey","guys","its","me"]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> generalCategory ' '
Space
ghci> generalCategory 'A'
UppercaseLetter
ghci> generalCategory 'a'
LowercaseLetter
ghci> generalCategory '.'
OtherPunctuation
ghci> generalCategory '9'
DecimalNumber
ghci> map generalCategory " \t\nA9?|"
[Space,Control,Control,UppercaseLetter,DecimalNumber,OtherPunctuation,MathSymbol]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map digitToInt "34538"
[3,4,5,3,8]
ghci> map digitToInt "FF85AB"
[15,15,8,5,10,11]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> intToDigit 15
'f'
ghci> intToDigit 5
'5'
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> ord 'a'
97
ghci> chr 97
'a'
ghci> map ord "abcdefgh"
[97,98,99,100,101,102,103,104]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
encode :: Int -> String -> String
encode shift msg =
    let ords = map ord msg
        shifted = map (+ shift) ords
    in  map chr shifted
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> encode 3 "Heeeeey"
"Khhhhh|"
ghci> encode 4 "Heeeeey"
"Liiiii}"
ghci> encode 1 "abcd"
"bcde"
ghci> encode 5 "Marry Christmas! Ho ho ho!"
"Rfww~%Hmwnxyrfx&%Mt%mt%mt&"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
decode :: Int -> String -> String
decode shift msg = encode (negate shift) msg
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> encode 3 "Im a little teapot"
"Lp#d#olwwoh#whdsrw"
ghci> decode 3 "Lp#d#olwwoh#whdsrw"
"Im a little teapot"
ghci> decode 5 . encode 5 $ "This is a sentence"
"This is a sentence"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
phoneBook =
    [("betty","555-2938")
    ,("bonnie","452-2928")
    ,("patsy","493-2928")
    ,("lucille","205-2928")
    ,("wendy","939-8282")
    ,("penny","853-2492")
    ]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
findKey :: (Eq k) => k -> [(k,v)] -> v
findKey key xs = snd . head . filter (\(k,v) -> key == k) $ xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
findKey :: (Eq k) => k -> [(k,v)] -> Maybe v
findKey key [] = Nothing
findKey key ((k,v):xs) = if key == k
                            then Just v
                            else findKey key xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
findKey :: (Eq k) => k -> [(k,v)] -> Maybe v
findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> findKey "penny" phoneBook
Just "853-2492"
ghci> findKey "betty" phoneBook
Just "555-2938"
ghci> findKey "wilma" phoneBook
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import qualified Data.Map as Map
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]
fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]
ghci> Map.fromList [(1,2),(3,4),(3,2),(5,5)]
fromList [(1,2),(3,2),(5,5)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
Map.fromList :: (Ord k) => [(k, v)] -> Map.Map k v
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.empty
fromList []
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.empty
fromList []
ghci> Map.insert 3 100 Map.empty
fromList [(3,100)]
ghci> Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty))
fromList [(3,100),(4,200),(5,600)]
ghci> Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty
fromList [(3,100),(4,200),(5,600)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fromList' :: (Ord k) => [(k,v)] -> Map.Map k v
fromList' = foldr (\(k,v) acc -> Map.insert k v acc) Map.empty
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.null Map.empty
True
ghci> Map.null $ Map.fromList [(2,3),(5,5)]
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.size Map.empty
0
ghci> Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]
5
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.singleton 3 9
fromList [(3,9)]
ghci> Map.insert 5 9 $ Map.singleton 3 9
fromList [(3,9),(5,9)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)]
True
ghci> Map.member 3 $ Map.fromList [(2,5),(4,5)]
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.map (*100) $ Map.fromList [(1,1),(2,4),(3,9)]
fromList [(1,100),(2,400),(3,900)]
ghci> Map.filter isUpper $ Map.fromList [(1,'a'),(2,'A'),(3,'b'),(4,'B')]
fromList [(2,'A'),(4,'B')]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.toList . Map.insert 9 2 $ Map.singleton 4 3
[(4,3),(9,2)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
phoneBook =
    [("betty","555-2938")
    ,("betty","342-2492")
    ,("bonnie","452-2928")
    ,("patsy","493-2928")
    ,("patsy","943-2929")
    ,("patsy","827-9162")
    ,("lucille","205-2928")
    ,("wendy","939-8282")
    ,("penny","853-2492")
    ,("penny","555-2111")
    ]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
phoneBookToMap :: (Ord k) => [(k, String)] -> Map.Map k String
phoneBookToMap xs = Map.fromListWith (\number1 number2 -> number1 ++ ", " ++ number2) xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.lookup "patsy" $ phoneBookToMap phoneBook
"827-9162, 943-2929, 493-2928"
ghci> Map.lookup "wendy" $ phoneBookToMap phoneBook
"939-8282"
ghci> Map.lookup "betty" $ phoneBookToMap phoneBook
"342-2492, 555-2938"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
phoneBookToMap :: (Ord k) => [(k, a)] -> Map.Map k [a]
phoneBookToMap xs = Map.fromListWith (++) $ map (\(k,v) -> (k,[v])) xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.lookup "patsy" $ phoneBookToMap phoneBook
["827-9162","943-2929","493-2928"]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,100),(3,29),(4,22)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,108),(3,62),(4,37)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)]
fromList [(3,104),(5,103),(6,339)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import qualified Data.Set as Set
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
text1 = "I just had an anime dream. Anime... Reality... Are they so different?"
text2 = "The old man left his garbage can out and now his trash is all over my lawn!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let set1 = Set.fromList text1
ghci> let set2 = Set.fromList text2
ghci> set1
fromList " .?AIRadefhijlmnorstuy"
ghci> set2
fromList " !Tabcdefghilmnorstuvwy"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Set.intersection set1 set2
fromList " adefhilmnorstuy"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Set.difference set1 set2
fromList ".?AIRj"
ghci> Set.difference set2 set1
fromList "!Tbcgvw"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Set.union set1 set2
fromList " !.?AIRTabcdefghijlmnorstuvwy"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Set.null Set.empty
True
ghci> Set.null $ Set.fromList [3,4,5,5,4,3]
False
ghci> Set.size $ Set.fromList [3,4,5,3,4,5]
3
ghci> Set.singleton 9
fromList [9]
ghci> Set.insert 4 $ Set.fromList [9,3,8,1]
fromList [1,3,4,8,9]
ghci> Set.insert 8 $ Set.fromList [5..10]
fromList [5,6,7,8,9,10]
ghci> Set.delete 4 $ Set.fromList [3,4,5,4,3,4,5]
fromList [3,5]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Set.fromList [2,3,4] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
True
ghci> Set.fromList [1,2,3,4,5] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
True
ghci> Set.fromList [1,2,3,4,5] `Set.isProperSubsetOf` Set.fromList [1,2,3,4,5]
False
ghci> Set.fromList [2,3,4,8] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Set.filter odd $ Set.fromList [3,4,5,6,7,2,3,4]
fromList [3,5,7]
ghci> Set.map (+1) $ Set.fromList [3,4,5,6,7,2,3,4]
fromList [3,4,5,6,7,8]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let setNub xs = Set.toList $ Set.fromList xs
ghci> setNub "HEY WHATS CRACKALACKIN"
" ACEHIKLNRSTWY"
ghci> nub "HEY WHATS CRACKALACKIN"
"HEY WATSCRKLIN"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
module Geometry
( sphereVolume
, sphereArea
, cubeVolume
, cubeArea
, cuboidArea
, cuboidVolume
) where
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
module Geometry
( sphereVolume
, sphereArea
, cubeVolume
, cubeArea
, cuboidArea
, cuboidVolume
) where

sphereVolume :: Float -> Float
sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)

sphereArea :: Float -> Float
sphereArea radius = 4 * pi * (radius ^ 2)

cubeVolume :: Float -> Float
cubeVolume side = cuboidVolume side side side

cubeArea :: Float -> Float
cubeArea side = cuboidArea side side side

cuboidVolume :: Float -> Float -> Float -> Float
cuboidVolume a b c = rectangleArea a b * c

cuboidArea :: Float -> Float -> Float -> Float
cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

rectangleArea :: Float -> Float -> Float
rectangleArea a b = a * b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Geometry
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
module Geometry.Sphere
( volume
, area
) where

volume :: Float -> Float
volume radius = (4.0 / 3.0) * pi * (radius ^ 3)

area :: Float -> Float
area radius = 4 * pi * (radius ^ 2)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
module Geometry.Cuboid
( volume
, area
) where

volume :: Float -> Float -> Float -> Float
volume a b c = rectangleArea a b * c

area :: Float -> Float -> Float -> Float
area a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

rectangleArea :: Float -> Float -> Float
rectangleArea a b = a * b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
module Geometry.Cube
( volume
, area
) where

import qualified Geometry.Cuboid as Cuboid

volume :: Float -> Float
volume side = Cuboid.volume side side side

area :: Float -> Float
area side = Cuboid.area side side side
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Geometry.Sphere
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import qualified Geometry.Sphere as Sphere
import qualified Geometry.Cuboid as Cuboid
import qualified Geometry.Cube as Cube
		 </code>
 	</pre> 
</div>

</div>

<h1 id="08-making-our-own-types-and-typeclasses"class="text-center font-bold text-4xl my-40">08-making-our-own-types-and-typeclasses</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Bool = False | True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Shape = Circle Float Float Float | Rectangle Float Float Float Float
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t Circle
Circle :: Float -> Float -> Float -> Shape
ghci> :t Rectangle
Rectangle :: Float -> Float -> Float -> Float -> Shape
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
surface :: Shape -> Float
surface (Circle _ _ r) = pi * r ^ 2
surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> surface $ Circle 10 20 10
314.15927
ghci> surface $ Rectangle 0 0 100 100
10000.0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Circle 10 20 5
Circle 10.0 20.0 5.0
ghci> Rectangle 50 230 60 90
Rectangle 50.0 230.0 60.0 90.0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map (Circle 10 20) [4,5,6,6]
[Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 6.0]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Point = Point Float Float deriving (Show)
data Shape = Circle Point Float | Rectangle Point Point deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
surface :: Shape -> Float
surface (Circle _ r) = pi * r ^ 2
surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> surface (Rectangle (Point 0 0) (Point 100 100))
10000.0
ghci> surface (Circle (Point 0 0) 24)
1809.5574
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
nudge :: Shape -> Float -> Float -> Shape
nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r
nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> nudge (Circle (Point 34 34) 10) 5 10
Circle (Point 39.0 44.0) 10.0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
baseCircle :: Float -> Shape
baseCircle r = Circle (Point 0 0) r

baseRect :: Float -> Float -> Shape
baseRect width height = Rectangle (Point 0 0) (Point width height)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> nudge (baseRect 40 100) 60 23
Rectangle (Point 60.0 23.0) (Point 100.0 123.0)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
module Shapes
( Point(..)
, Shape(..)
, surface
, nudge
, baseCircle
, baseRect
) where
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Person = Person String String Int Float String String deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
ghci> guy
Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
firstName :: Person -> String
firstName (Person firstname _ _ _ _ _) = firstname

lastName :: Person -> String
lastName (Person _ lastname _ _ _ _) = lastname

age :: Person -> Int
age (Person _ _ age _ _ _) = age

height :: Person -> Float
height (Person _ _ _ height _ _) = height

phoneNumber :: Person -> String
phoneNumber (Person _ _ _ _ number _) = number

flavor :: Person -> String
flavor (Person _ _ _ _ _ flavor) = flavor
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
ghci> firstName guy
"Buddy"
ghci> height guy
184.2
ghci> flavor guy
"Chocolate"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     , height :: Float
                     , phoneNumber :: String
                     , flavor :: String
                     } deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t flavor
flavor :: Person -> String
ghci> :t firstName
firstName :: Person -> String
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Car = Car String String Int deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Car "Ford" "Mustang" 1967
Car "Ford" "Mustang" 1967
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Car = Car {company :: String, model :: String, year :: Int} deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Car {company="Ford", model="Mustang", year=1967}
Car {company = "Ford", model = "Mustang", year = 1967}
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Maybe a = Nothing | Just a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Just "Haha"
Just "Haha"
ghci> Just 84
Just 84
ghci> :t Just "Haha"
Just "Haha" :: Maybe [Char]
ghci> :t Just 84
Just 84 :: (Num t) => Maybe t
ghci> :t Nothing
Nothing :: Maybe a
ghci> Just 10 :: Maybe Double
Just 10.0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Car = Car { company :: String
               , model :: String
               , year :: Int
               } deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Car a b c = Car { company :: a
                     , model :: b
                     , year :: c
                     } deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
tellCar :: Car -> String
tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let stang = Car {company="Ford", model="Mustang", year=1967}
ghci> tellCar stang
"This Ford Mustang was made in 1967"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
tellCar :: (Show a) => Car String String a -> String
tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> tellCar (Car "Ford" "Mustang" 1967)
"This Ford Mustang was made in 1967"
ghci> tellCar (Car "Ford" "Mustang" "nineteen sixty seven")
"This Ford Mustang was made in \"nineteen sixty seven\""
ghci> :t Car "Ford" "Mustang" 1967
Car "Ford" "Mustang" 1967 :: (Num t) => Car [Char] [Char] t
ghci> :t Car "Ford" "Mustang" "nineteen sixty seven"
Car "Ford" "Mustang" "nineteen sixty seven" :: Car [Char] [Char] [Char]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data (Ord k) => Map k v = ...
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Vector a = Vector a a a deriving (Show)

vplus :: (Num t) => Vector t -> Vector t -> Vector t
(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)

vectMult :: (Num t) => Vector t -> t -> Vector t
(Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m)

scalarMult :: (Num t) => Vector t -> Vector t -> t
(Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Vector 3 5 8 `vplus` Vector 9 2 8
Vector 12 7 16
ghci> Vector 3 5 8 `vplus` Vector 9 2 8 `vplus` Vector 0 2 3
Vector 12 9 19
ghci> Vector 3 9 7 `vectMult` 10
Vector 30 90 70
ghci> Vector 4 9 5 `scalarMult` Vector 9.0 2.0 4.0
74.0
ghci> Vector 2 9 3 `vectMult` (Vector 4 9 5 `scalarMult` Vector 9 2 4)
Vector 148 666 222
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     } deriving (Eq)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}
ghci> let adRock = Person {firstName = "Adam", lastName = "Horovitz", age = 41}
ghci> let mca = Person {firstName = "Adam", lastName = "Yauch", age = 44}
ghci> mca == adRock
False
ghci> mikeD == adRock
False
ghci> mikeD == mikeD
True
ghci> mikeD == Person {firstName = "Michael", lastName = "Diamond", age = 43}
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let beastieBoys = [mca, adRock, mikeD]
ghci> mikeD `elem` beastieBoys
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     } deriving (Eq, Show, Read)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}
ghci> mikeD
Person {firstName = "Michael", lastName = "Diamond", age = 43}
ghci> "mikeD is: " ++ show mikeD
"mikeD is: Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" :: Person
Person {firstName = "Michael", lastName = "Diamond", age = 43}
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" == mikeD
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Bool = False | True deriving (Ord)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> True `compare` False
GT
ghci> True > False
True
ghci> True < False
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Nothing < Just 100
True
ghci> Nothing > Just (-49999)
False
ghci> Just 3 `compare` Just 2
GT
ghci> Just 100 > Just 50
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
           deriving (Eq, Ord, Show, Read, Bounded, Enum)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Wednesday
Wednesday
ghci> show Wednesday
"Wednesday"
ghci> read "Saturday" :: Day
Saturday
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Saturday == Sunday
False
ghci> Saturday == Saturday
True
ghci> Saturday > Friday
True
ghci> Monday `compare` Wednesday
LT
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> minBound :: Day
Monday
ghci> maxBound :: Day
Sunday
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> succ Monday
Tuesday
ghci> pred Saturday
Friday
ghci> [Thursday .. Sunday]
[Thursday,Friday,Saturday,Sunday]
ghci> [minBound .. maxBound] :: [Day]
[Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
 type String = [Char]

		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
phoneBook :: [(String,String)]
phoneBook =
    [("betty","555-2938")
    ,("bonnie","452-2928")
    ,("patsy","493-2928")
    ,("lucille","205-2928")
    ,("wendy","939-8282")
    ,("penny","853-2492")
    ]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type PhoneBook = [(String,String)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type PhoneNumber = String
type Name = String
type PhoneBook = [(Name,PhoneNumber)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
inPhoneBook :: Name -> PhoneNumber -> PhoneBook -> Bool
inPhoneBook name pnumber pbook = (name,pnumber) `elem` pbook
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type AssocList k v = [(k,v)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type IntMap v = Map Int v
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type IntMap = Map Int
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Right 20
Right 20
ghci> Left "w00t"
Left "w00t"
ghci> :t Right 'a'
Right 'a' :: Either a Char
ghci> :t Left True
Left True :: Either Bool b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import qualified Data.Map as Map

data LockerState = Taken | Free deriving (Show, Eq)

type Code = String

type LockerMap = Map.Map Int (LockerState, Code)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
lockerLookup :: Int -> LockerMap -> Either String Code
lockerLookup lockerNumber map =
    case Map.lookup lockerNumber map of
        Nothing -> Left $ "Locker number " ++ show lockerNumber ++ " doesn't exist!"
        Just (state, code) -> if state /= Taken
                                then Right code
                                else Left $ "Locker " ++ show lockerNumber ++ " is already taken!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
lockers :: LockerMap
lockers = Map.fromList
    [(100,(Taken,"ZD39I"))
    ,(101,(Free,"JAH3I"))
    ,(103,(Free,"IQSA9"))
    ,(105,(Free,"QOTSA"))
    ,(109,(Taken,"893JJ"))
    ,(110,(Taken,"99292"))
    ]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> lockerLookup 101 lockers
Right "JAH3I"
ghci> lockerLookup 100 lockers
Left "Locker 100 is already taken!"
ghci> lockerLookup 102 lockers
Left "Locker number 102 doesn't exist!"
ghci> lockerLookup 110 lockers
Left "Locker 110 is already taken!"
ghci> lockerLookup 105 lockers
Right "QOTSA"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data List a = Empty | Cons { listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Empty
Empty
ghci> 5 `Cons` Empty
Cons 5 Empty
ghci> 4 `Cons` (5 `Cons` Empty)
Cons 4 (Cons 5 Empty)
ghci> 3 `Cons` (4 `Cons` (5 `Cons` Empty))
Cons 3 (Cons 4 (Cons 5 Empty))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
infixr 5 :-:
data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 3 :-: 4 :-: 5 :-: Empty
(:-:) 3 ((:-:) 4 ((:-:) 5 Empty))
ghci> let a = 3 :-: 4 :-: 5 :-: Empty
ghci> 100 :-: a
(:-:) 100 ((:-:) 3 ((:-:) 4 ((:-:) 5 Empty)))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
infixr 5  ++
(++) :: [a] -> [a] -> [a]
[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
infixr 5  .++
(.++) :: List a -> List a -> List a
Empty .++ ys = ys
(x :-: xs) .++ ys = x :-: (xs .++ ys)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let a = 3 :-: 4 :-: 5 :-: Empty
ghci> let b = 6 :-: 7 :-: Empty
ghci> a .++ b
(:-:) 3 ((:-:) 4 ((:-:) 5 ((:-:) 6 ((:-:) 7 Empty))))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
singleton :: a -> Tree a
singleton x = Node x EmptyTree EmptyTree

treeInsert :: (Ord a) => a -> Tree a -> Tree a
treeInsert x EmptyTree = singleton x
treeInsert x (Node a left right)
    | x == a = Node x left right
    | x < a  = Node a (treeInsert x left) right
    | x > a  = Node a left (treeInsert x right)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
treeElem :: (Ord a) => a -> Tree a -> Bool
treeElem x EmptyTree = False
treeElem x (Node a left right)
    | x == a = True
    | x < a  = treeElem x left
    | x > a  = treeElem x right
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let nums = [8,6,4,1,7,3,5]
ghci> let numsTree = foldr treeInsert EmptyTree nums
ghci> numsTree
Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 8 `treeElem` numsTree
True
ghci> 100 `treeElem` numsTree
False
ghci> 1 `treeElem` numsTree
True
ghci> 10 `treeElem` numsTree
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data TrafficLight = Red | Yellow | Green
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Show TrafficLight where
    show Red = "Red light"
    show Yellow = "Yellow light"
    show Green = "Green light"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Red == Red
True
ghci> Red == Yellow
False
ghci> Red `elem` [Red, Yellow, Green]
True
ghci> [Red, Yellow, Green]
[Red light,Yellow light,Green light]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class (Eq a) => Num a where
   ...
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Eq Maybe where
    ...
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Eq (Maybe m) where
    Just x == Just y = x == y
    Nothing == Nothing = True
    _ == _ = False

		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance (Eq m) => Eq (Maybe m) where
    Just x == Just y = x == y
    Nothing == Nothing = True
    _ == _ = False

		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class YesNo a where
    yesno :: a -> Bool
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance YesNo Int where
    yesno 0 = False
    yesno _ = True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance YesNo [a] where
    yesno [] = False
    yesno _ = True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance YesNo Bool where
    yesno = id
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance YesNo (Maybe a) where
    yesno (Just _) = True
    yesno Nothing = False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance YesNo (Tree a) where
    yesno EmptyTree = False
    yesno _ = True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance YesNo TrafficLight where
    yesno Red = False
    yesno _ = True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> yesno $ length []
False
ghci> yesno "haha"
True
ghci> yesno ""
False
ghci> yesno $ Just 0
True
ghci> yesno True
True
ghci> yesno EmptyTree
False
ghci> yesno []
False
ghci> yesno [0,0,0]
True
ghci> :t yesno
yesno :: (YesNo a) => a -> Bool
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
yesnoIf :: (YesNo y) => y -> a -> a -> a
yesnoIf yesnoVal yesResult noResult = if yesno yesnoVal then yesResult else noResult
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> yesnoIf [] "YEAH!" "NO!"
"NO!"
ghci> yesnoIf [2,3,4] "YEAH!" "NO!"
"YEAH!"
ghci> yesnoIf True "YEAH!" "NO!"
"YEAH!"
ghci> yesnoIf (Just 500) "YEAH!" "NO!"
"YEAH!"
ghci> yesnoIf Nothing "YEAH!" "NO!"
"NO!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Functor f where
    fmap :: (a -> b) -> f a -> f b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor [] where
    fmap = map
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
map :: (a -> b) -> [a] -> [b]
ghci> fmap (*2) [1..3]
[2,4,6]
ghci> map (*2) [1..3]
[2,4,6]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fmap (++ " HEY GUYS IM INSIDE THE JUST") (Just "Something serious.")
Just "Something serious. HEY GUYS IM INSIDE THE JUST"
ghci> fmap (++ " HEY GUYS IM INSIDE THE JUST") Nothing
Nothing
ghci> fmap (*2) (Just 200)
Just 400
ghci> fmap (*2) Nothing
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor Tree where
    fmap f EmptyTree = EmptyTree
    fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f rightsub)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fmap (*2) EmptyTree
EmptyTree
ghci> fmap (*4) (foldr treeInsert EmptyTree [5,7,3,2,1,7])
Node 28 (Node 4 EmptyTree (Node 8 EmptyTree (Node 12 EmptyTree (Node 20 EmptyTree EmptyTree)))) EmptyTree
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor (Either a) where
    fmap f (Right x) = Right (f x)
    fmap f (Left x) = Left x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Either a b = Left a | Right b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :k Int
Int :: *
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :k Maybe
Maybe :: * -> *
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :k Maybe Int
Maybe Int :: *
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :k Either
Either :: * -> * -> *
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :k Either String
Either String :: * -> *
ghci> :k Either String Int
Either String Int :: *
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Functor f where
    fmap :: (a -> b) -> f a -> f b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Tofu t where
    tofu :: j a -> t a j
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Frank a b  = Frank {frankField :: b a} deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t Frank {frankField = Just "HAHA"}
Frank {frankField = Just "HAHA"} :: Frank [Char] Maybe
ghci> :t Frank {frankField = Node 'a' EmptyTree EmptyTree}
Frank {frankField = Node 'a' EmptyTree EmptyTree} :: Frank Char Tree
ghci> :t Frank {frankField = "YES"}
Frank {frankField = "YES"} :: Frank Char []
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Tofu Frank where
    tofu x = Frank x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> tofu (Just 'a') :: Frank Char Maybe
Frank {frankField = Just 'a'}
ghci> tofu ["HELLO"] :: Frank [Char] []
Frank {frankField = ["HELLO"]}
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Barry t k p = Barry { yabba :: p, dabba :: t k }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :k Barry
Barry :: (* -> *) -> * -> * -> *
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor (Barry a b) where
    fmap f (Barry {yabba = x, dabba = y}) = Barry {yabba = f x, dabba = y}
		 </code>
 	</pre> 
</div>

</div>

<h1 id="09-input-and-output"class="text-center font-bold text-4xl my-40">09-input-and-output</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = putStrLn "hello, world"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ ghc --make helloworld
[1 of 1] Compiling Main             ( helloworld.hs, helloworld.o )
Linking helloworld ...
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ ./helloworld
hello, world
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t putStrLn
putStrLn :: String -> IO ()
ghci> :t putStrLn "hello, world"
putStrLn "hello, world" :: IO ()
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t getLine
getLine :: IO String
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn $ "Read this carefully, because this is your future: " ++ tellFortune name
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
nameTag = "Hello, my name is " ++ getLine
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    foo <- putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
name = getLine
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> putStrLn "HEEY"
HEEY
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.Char

main = do
    putStrLn "What's your first name?"
    firstName <- getLine
    putStrLn "What's your last name?"
    lastName <- getLine
    let bigFirstName = map toUpper firstName
        bigLastName = map toUpper lastName
    putStrLn $ "hey " ++ bigFirstName ++ " " ++ bigLastName ++ ", how are you?"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    line <- getLine
    if null line
        then return ()
        else do
            putStrLn $ reverseWords line
            main

reverseWords :: String -> String
reverseWords = unwords . map reverse . words
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
        else (do
            putStrLn $ reverseWords line
            main)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    return ()
    return "HAHAHA"
    line <- getLine
    return "BLAH BLAH BLAH"
    return 4
    putStrLn line
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    a <- return "hell"
    b <- return "yeah!"
    putStrLn $ a ++ " " ++ b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    let a = "hell"
        b = "yeah"
    putStrLn $ a ++ " " ++ b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do   putStr "Hey, "
            putStr "I'm "
            putStrLn "Andy!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell putstr_test.hs
Hey, I'm Andy!
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do   putChar 't'
            putChar 'e'
            putChar 'h'
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell putchar_test.hs
teh
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
putStr :: String -> IO ()
putStr [] = return ()
putStr (x:xs) = do
    putChar x
    putStr xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do   print True
            print 2
            print "haha"
            print 3.2
            print [3,4,3]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell print_test.hs
True
2
"haha"
3.2
[3,4,3]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 3
3
ghci> print 3
3
ghci> map (++"!") ["hey","ho","woo"]
["hey!","ho!","woo!"]
ghci> print (map (++"!") ["hey","ho","woo"])
["hey!","ho!","woo!"]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    c <- getChar
    if c /= ' '
        then do
            putChar c
            main
        else return ()
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell getchar_test.hs
hello sir
hello
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad

main = do
    c <- getChar
    when (c /= ' ') $ do
        putChar c
        main
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    a <- getLine
    b <- getLine
    c <- getLine
    print [a,b,c]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    rs <- sequence [getLine, getLine, getLine]
    print rs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sequence (map print [1,2,3,4,5])
1
2
3
4
5
[(),(),(),(),()]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> mapM print [1,2,3]
1
2
3
[(),(),()]
ghci> mapM_ print [1,2,3]
1
2
3
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad
import Data.Char

main = forever $ do
    putStr "Give me some input: "
    l <- getLine
    putStrLn $ map toUpper l
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad

main = do
    colors <- forM [1,2,3,4] (\a -> do
        putStrLn $ "Which color do you associate with the number " ++ show a ++ "?"
        color <- getLine
        return color)
    putStrLn "The colors that you associate with 1, 2, 3 and 4 are: "
    mapM putStrLn colors
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell form_test.hs
Which color do you associate with the number 1?
white
Which color do you associate with the number 2?
blue
Which color do you associate with the number 3?
red
Which color do you associate with the number 4?
orange
The colors that you associate with 1, 2, 3 and 4 are:
white
blue
red
orange
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad
import Data.Char

main = forever $ do
    putStr "Give me some input: "
    l <- getLine
    putStrLn $ map toUpper l
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ ghc --make capslocker
[1 of 1] Compiling Main             ( capslocker.hs, capslocker.o )
Linking capslocker ...
$ cat haiku.txt
I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless
$ cat haiku.txt | ./capslocker
I'M A LIL' TEAPOT
WHAT'S WITH THAT AIRPLANE FOOD, HUH?
IT'S SO SMALL, TASTELESS
capslocker <stdin>: hGetLine: end of file
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.Char

main = do
    contents <- getContents
    putStr (map toUpper contents)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ cat haiku.txt | ./capslocker
I'M A LIL' TEAPOT
WHAT'S WITH THAT AIRPLANE FOOD, HUH?
IT'S SO SMALL, TASTELESS
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ ./capslocker
hey ho
HEY HO
lets go
LETS GO
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    contents <- getContents
    putStr (shortLinesOnly contents)

shortLinesOnly :: String -> String
shortLinesOnly input =
    let allLines = lines input
        shortLines = filter (\line -> length line < 10) allLines
        result = unlines shortLines
    in  result
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
i'm short
so am i
i am a loooooooooong line!!!
yeah i'm long so what hahahaha!!!!!!
short line
loooooooooooooooooooooooooooong
short
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ ghc --make shortlinesonly
[1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )
Linking shortlinesonly ...
$ cat shortlines.txt | ./shortlinesonly
i'm short
so am i
short
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = interact shortLinesOnly

shortLinesOnly :: String -> String
shortLinesOnly input =
    let allLines = lines input
        shortLines = filter (\line -> length line < 10) allLines
        result = unlines shortLines
    in  result
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = interact $ unlines . filter ((<10) . length) . lines
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
respondPalindromes contents = unlines (map (\xs -> if isPalindrome xs then "palindrome" else "not a palindrome") (lines contents))
    where   isPalindrome xs = xs == reverse xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
respondPalindromes = unlines . map (\xs -> if isPalindrome xs then "palindrome" else "not a palindrome") . lines
    where   isPalindrome xs = xs == reverse xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = interact respondPalindromes
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell palindromes.hs
hehe
not a palindrome
ABCBA
palindrome
cookie
not a palindrome
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
dogaroo
radar
rotor
madam
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ cat words.txt | runhaskell palindromes.hs
not a palindrome
palindrome
palindrome
palindrome
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
Hey! Hey! You! You!
I don't like your girlfriend!
No way! No way!
I think you need a new one!
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.IO

main = do
    handle <- openFile "girlfriend.txt" ReadMode
    contents <- hGetContents handle
    putStr contents
    hClose handle
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell girlfriend.hs
Hey! Hey! You! You!
I don't like your girlfriend!
No way! No way!
I think you need a new one!
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type FilePath = String
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.IO

main = do
    withFile "girlfriend.txt" ReadMode (\handle -> do
        contents <- hGetContents handle
        putStr contents)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
withFile' :: FilePath -> IOMode -> (Handle -> IO a) -> IO a
withFile' path mode f = do
    handle <- openFile path mode
    result <- f handle
    hClose handle
    return result
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.IO

main = do
    contents <- readFile "girlfriend.txt"
    putStr contents
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.IO
import Data.Char

main = do
    contents <- readFile "girlfriend.txt"
    writeFile "girlfriendcaps.txt" (map toUpper contents)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell girlfriendtocaps.hs
$ cat girlfriendcaps.txt
HEY! HEY! YOU! YOU!
I DON'T LIKE YOUR GIRLFRIEND!
NO WAY! NO WAY!
I THINK YOU NEED A NEW ONE!
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.IO

main = do
    todoItem <- getLine
    appendFile "todo.txt" (todoItem ++ "\n")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell appendtodo.hs
Iron the dishes
$ runhaskell appendtodo.hs
Dust the dog
$ runhaskell appendtodo.hs
Take salad out of the oven
$ cat todo.txt
Iron the dishes
Dust the dog
Take salad out of the oven
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    withFile "something.txt" ReadMode (\handle -> do
        contents <- hGetContents handle
        putStr contents)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    withFile "something.txt" ReadMode (\handle -> do
        hSetBuffering handle $ BlockBuffering (Just 2048)
        contents <- hGetContents handle
        putStr contents)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.IO
import System.Directory
import Data.List

main = do
    handle <- openFile "todo.txt" ReadMode
    (tempName, tempHandle) <- openTempFile "." "temp"
    contents <- hGetContents handle
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -> show n ++ " - " ++ line) [0..] todoTasks
    putStrLn "These are your TO-DO items:"
    putStr $ unlines numberedTasks
    putStrLn "Which one do you want to delete?"
    numberString <- getLine
    let number = read numberString
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile "todo.txt"
    renameFile tempName "todo.txt"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell deletetodo.hs
These are your TO-DO items:
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven
Which one do you want to delete?
1

$ cat todo.txt
Iron the dishes
Take salad out of the oven

$ runhaskell deletetodo.hs
These are your TO-DO items:
0 - Iron the dishes
1 - Take salad out of the oven
Which one do you want to delete?
0

$ cat todo.txt
Take salad out of the oven
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
 import System.Environment
 import Data.List

 main = do
    args <- getArgs
    progName <- getProgName
    putStrLn "The arguments are:"
    mapM putStrLn args
    putStrLn "The program name is:"
    putStrLn progName
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ ./arg-test first second w00t "multi word arg"
The arguments are:
first
second
w00t
multi word arg
The program name is:
arg-test
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Environment
import System.Directory
import System.IO
import Data.List

dispatch :: [(String, [String] -> IO ())]
dispatch =  [ ("add", add)
            , ("view", view)
            , ("remove", remove)
            ]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    (command:args) <- getArgs
    let (Just action) = lookup command dispatch
    action args
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
add :: [String] -> IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
view :: [String] -> IO ()
view [fileName] = do
    contents <- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -> show n ++ " - " ++ line) [0..] todoTasks
    putStr $ unlines numberedTasks
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
remove :: [String] -> IO ()
remove [fileName, numberString] = do
    handle <- openFile fileName ReadMode
    (tempName, tempHandle) <- openTempFile "." "temp"
    contents <- hGetContents handle
    let number = read numberString
        todoTasks = lines contents
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Environment
import System.Directory
import System.IO
import Data.List

dispatch :: [(String, [String] -> IO ())]
dispatch =  [ ("add", add)
            , ("view", view)
            , ("remove", remove)
            ]

main = do
    (command:args) <- getArgs
    let (Just action) = lookup command dispatch
    action args

add :: [String] -> IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")

view :: [String] -> IO ()
view [fileName] = do
    contents <- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -> show n ++ " - " ++ line) [0..] todoTasks
    putStr $ unlines numberedTasks

remove :: [String] -> IO ()
remove [fileName, numberString] = do
    handle <- openFile fileName ReadMode
    (tempName, tempHandle) <- openTempFile "." "temp"
    contents <- hGetContents handle
    let number = read numberString
        todoTasks = lines contents
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven

$ ./todo add todo.txt "Pick up children from drycleaners"

$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven
3 - Pick up children from drycleaners

$ ./todo remove todo.txt 2

$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Pick up children from drycleaners
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
randomNumber :: (Num a) => a
randomNumber = 4
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> random (mkStdGen 100)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
<interactive>:1:0:
    Ambiguous type variable `a' in the constraint:
      `Random a' arising from a use of `random' at <interactive>:1:0-20
    Probable fix: add a type signature that fixes these type variable(s)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> random (mkStdGen 100) :: (Int, StdGen)
(-1352021624,651872571 1655838864)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> random (mkStdGen 100) :: (Int, StdGen)
(-1352021624,651872571 1655838864)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> random (mkStdGen 949494) :: (Int, StdGen)
(539963926,466647808 1655838864)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> random (mkStdGen 949488) :: (Float, StdGen)
(0.8938442,1597344447 1655838864)
ghci> random (mkStdGen 949488) :: (Bool, StdGen)
(False,1485632275 40692)
ghci> random (mkStdGen 949488) :: (Integer, StdGen)
(1691547873,1597344447 1655838864)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
threeCoins :: StdGen -> (Bool, Bool, Bool)
threeCoins gen =
    let (firstCoin, newGen) = random gen
        (secondCoin, newGen') = random newGen
        (thirdCoin, newGen'') = random newGen'
    in  (firstCoin, secondCoin, thirdCoin)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> threeCoins (mkStdGen 21)
(True,True,True)
ghci> threeCoins (mkStdGen 22)
(True,False,True)
ghci> threeCoins (mkStdGen 943)
(True,False,True)
ghci> threeCoins (mkStdGen 944)
(True,True,True)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> take 5 $ randoms (mkStdGen 11) :: [Int]
[-1807975507,545074951,-1015194702,-1622477312,-502893664]
ghci> take 5 $ randoms (mkStdGen 11) :: [Bool]
[True,True,True,True,False]
ghci> take 5 $ randoms (mkStdGen 11) :: [Float]
[7.904789e-2,0.62691015,0.26363158,0.12223756,0.38291094]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
randoms' :: (RandomGen g, Random a) => g -> [a]
randoms' gen = let (value, newGen) = random gen in value:randoms' newGen
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
finiteRandoms :: (RandomGen g, Random a, Num n) => n -> g -> ([a], g)
finiteRandoms 0 gen = ([], gen)
finiteRandoms n gen =
    let (value, newGen) = random gen
        (restOfList, finalGen) = finiteRandoms (n-1) newGen
    in  (value:restOfList, finalGen)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> randomR (1,6) (mkStdGen 359353)
(6,1494289578 40692)
ghci> randomR (1,6) (mkStdGen 35935335)
(3,1250031057 40692)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> take 10 $ randomRs ('a','z') (mkStdGen 3) :: [Char]
"ndkxbvmomg"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Random

main = do
    gen <- getStdGen
    putStr $ take 20 (randomRs ('a','z') gen)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell random_string.hs
pybphhzzhuepknbykxhe
$ runhaskell random_string.hs
eiqgcxykivpudlsvvjpg
$ runhaskell random_string.hs
nzdceoconysdgcyqjruo
$ runhaskell random_string.hs
bakzhnnuzrkgvesqplrx
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Random

main = do
    gen <- getStdGen
    putStrLn $ take 20 (randomRs ('a','z') gen)
    gen2 <- getStdGen
    putStr $ take 20 (randomRs ('a','z') gen2)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Random
import Data.List

main = do
    gen <- getStdGen
    let randomChars = randomRs ('a','z') gen
        (first20, rest) = splitAt 20 randomChars
        (second20, _) = splitAt 20 rest
    putStrLn first20
    putStr second20
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Random

main = do
    gen <- getStdGen
    putStrLn $ take 20 (randomRs ('a','z') gen)
    gen' <- newStdGen
    putStr $ take 20 (randomRs ('a','z') gen')
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Random
import Control.Monad(when)

main = do
    gen <- getStdGen
    askForNumber gen

askForNumber :: StdGen -> IO ()
askForNumber gen = do
    let (randNumber, newGen) = randomR (1,10) gen :: (Int, StdGen)
    putStr "Which number in the range from 1 to 10 am I thinking of? "
    numberString <- getLine
    when (not $ null numberString) $ do
        let number = read numberString
        if randNumber == number
            then putStrLn "You are correct!"
            else putStrLn $ "Sorry, it was " ++ show randNumber
        askForNumber newGen
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell guess_the_number.hs
Which number in the range from 1 to 10 am I thinking of? 4
Sorry, it was 3
Which number in the range from 1 to 10 am I thinking of? 10
You are correct!
Which number in the range from 1 to 10 am I thinking of? 2
Sorry, it was 4
Which number in the range from 1 to 10 am I thinking of? 5
Sorry, it was 10
Which number in the range from 1 to 10 am I thinking of?
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Random
import Control.Monad(when)

main = do
    gen <- getStdGen
    let (randNumber, _) = randomR (1,10) gen :: (Int, StdGen)
    putStr "Which number in the range from 1 to 10 am I thinking of? "
    numberString <- getLine
    when (not $ null numberString) $ do
        let number = read numberString
        if randNumber == number
            then putStrLn "You are correct!"
            else putStrLn $ "Sorry, it was " ++ show randNumber
        newStdGen
        main
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString as S
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> B.pack [99,97,110]
Chunk "can" Empty
ghci> B.pack [98..120]
Chunk "bcdefghijklmnopqrstuvwx" Empty
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> B.fromChunks [S.pack [40,41,42], S.pack [43,44,45], S.pack [46,47,48]]
Chunk "()*" (Chunk "+,-" (Chunk "./0" Empty))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> B.cons 85 $ B.pack [80,81,82,84]
Chunk "U" (Chunk "PQRT" Empty)
ghci> B.cons' 85 $ B.pack [80,81,82,84]
Chunk "UPQRT" Empty
ghci> foldr B.cons B.empty [50..60]
Chunk "2" (Chunk "3" (Chunk "4" (Chunk "5" (Chunk "6" (Chunk "7" (Chunk "8" (Chunk "9" (Chunk ":" (Chunk ";" (Chunk "<"
Empty))))))))))
ghci> foldr B.cons' B.empty [50..60]
Chunk "23456789:;<" Empty
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Environment
import qualified Data.ByteString.Lazy as B

main = do
    (fileName1:fileName2:_) <- getArgs
    copyFile fileName1 fileName2

copyFile :: FilePath -> FilePath -> IO ()
copyFile source dest = do
    contents <- B.readFile source
    B.writeFile dest contents
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell bytestringcopy.hs something.txt ../../something.txt
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 4 `div` 0
*** Exception: divide by zero
ghci> head []
*** Exception: Prelude.head: empty list
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Environment
import System.IO

main = do (fileName:_) <- getArgs
          contents <- readFile fileName
          putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell linecount.hs i_dont_exist.txt
linecount.hs: i_dont_exist.txt: openFile: does not exist (No such file or directory)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Environment
import System.IO
import System.Directory

main = do (fileName:_) <- getArgs
          fileExists <- doesFileExist fileName
          if fileExists
              then do contents <- readFile fileName
                      putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"
              else do putStrLn "The file doesn't exist!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Environment
import System.IO
import System.IO.Error

main = toTry `catch` handler

toTry :: IO ()
toTry = do (fileName:_) <- getArgs
           contents <- readFile fileName
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"

handler :: IOError -> IO ()
handler e = putStrLn "Whoops, had some trouble!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell count_lines.hs i_exist.txt
The file has 3 lines!

$ runhaskell count_lines.hs i_dont_exist.txt
Whoops, had some trouble!
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Environment
import System.IO
import System.IO.Error

main = toTry `catch` handler

toTry :: IO ()
toTry = do (fileName:_) <- getArgs
           contents <- readFile fileName
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"

handler :: IOError -> IO ()
handler e
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"
    | otherwise = ioError e
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
handler :: IOError -> IO ()
handler e
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"
    | isFullError e = freeSomeSpace
    | isIllegalOperation e = notifyCops
    | otherwise = ioError e
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Environment
import System.IO
import System.IO.Error

main = toTry `catch` handler

toTry :: IO ()
toTry = do (fileName:_) <- getArgs
           contents <- readFile fileName
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"

handler :: IOError -> IO ()
handler e
    | isDoesNotExistError e =
        case ioeGetFileName e of Just path -> putStrLn $ "Whoops! File does not exist at: " ++ path
                                 Nothing -> putStrLn "Whoops! File does not exist at unknown location!"
    | otherwise = ioError e
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do toTry `catch` handler1
          thenTryThis `catch` handler2
          launchRockets
		 </code>
 	</pre> 
</div>

</div>

<h1 id="10-functionally-solving-problems"class="text-center font-bold text-4xl my-40">10-functionally-solving-problems</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List

solveRPN :: (Num a) => String -> a
solveRPN expression = head (foldl foldingFunction [] (words expression))
    where   foldingFunction stack item = ...
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List

solveRPN :: (Num a) => String -> a
solveRPN = head . foldl foldingFunction [] . words
    where   foldingFunction stack item = ...
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
solveRPN :: (Num a, Read a) => String -> a
solveRPN = head . foldl foldingFunction [] . words
    where   foldingFunction (x:y:ys) "*" = (x * y):ys
            foldingFunction (x:y:ys) "+" = (x + y):ys
            foldingFunction (x:y:ys) "-" = (y - x):ys
            foldingFunction xs numberString = read numberString:xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> solveRPN "10 4 3 + 2 * -"
-4
ghci> solveRPN "2 3 +"
5
ghci> solveRPN "90 34 12 33 55 66 + * - +"
-3947
ghci> solveRPN "90 34 12 33 55 66 + * - + -"
4037
ghci> solveRPN "90 34 12 33 55 66 + * - + -"
4037
ghci> solveRPN "90 3 -"
87
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List

solveRPN :: String -> Float
solveRPN = head . foldl foldingFunction [] . words
    where   foldingFunction (x:y:ys) "*" = (x * y):ys
            foldingFunction (x:y:ys) "+" = (x + y):ys
            foldingFunction (x:y:ys) "-" = (y - x):ys
            foldingFunction (x:y:ys) "/" = (y / x):ys
            foldingFunction (x:y:ys) "^" = (y ** x):ys
            foldingFunction (x:xs) "ln" = log x:xs
            foldingFunction xs "sum" = [sum xs]
            foldingFunction xs numberString = read numberString:xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> solveRPN "2.7 ln"
0.9932518
ghci> solveRPN "10 10 10 10 sum 4 /"
10.0
ghci> solveRPN "10 10 10 10 10 sum 4 /"
12.5
ghci> solveRPN "10 2 ^"
100.0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> solveRPN "43.2425 0.5 ^"
6.575903
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
50
10
30
5
90
20
40
2
25
10
8
0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Node = Node Road Road | EndNode Road
data Road = Road Int Node
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Node = Node Road (Maybe Road)
data Road = Road Int Node
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Section = Section { getA :: Int, getB :: Int, getC :: Int } deriving (Show)
type RoadSystem = [Section]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
heathrowToLondon :: RoadSystem
heathrowToLondon = [Section 50 10 30, Section 5 90 20, Section 40 2 25, Section 10 8 0]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Label = A | B | C deriving (Show)
type Path = [(Label, Int)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
roadStep :: (Path, Path) -> Section -> (Path, Path)
roadStep (pathA, pathB) (Section a b c) =
    let priceA = sum $ map snd pathA
        priceB = sum $ map snd pathB
        forwardPriceToA = priceA + a
        crossPriceToA = priceB + b + c
        forwardPriceToB = priceB + b
        crossPriceToB = priceA + a + c
        newPathToA = if forwardPriceToA <= crossPriceToA
                        then (A,a):pathA
                        else (C,c):(B,b):pathB
        newPathToB = if forwardPriceToB <= crossPriceToB
                        then (B,b):pathB
                        else (C,c):(A,a):pathA
    in  (newPathToA, newPathToB)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> roadStep ([], []) (head heathrowToLondon)
([(C,30),(B,10)],[(B,10)])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
optimalPath :: RoadSystem -> Path
optimalPath roadSystem =
    let (bestAPath, bestBPath) = foldl roadStep ([],[]) roadSystem
    in  if sum (map snd bestAPath) <= sum (map snd bestBPath)
            then reverse bestAPath
            else reverse bestBPath
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> optimalPath heathrowToLondon
[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8),(C,0)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
groupsOf :: Int -> [a] -> [[a]]
groupsOf 0 _ = undefined
groupsOf _ [] = []
groupsOf n xs = take n xs : groupsOf n (drop n xs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List

main = do
    contents <- getContents
    let threes = groupsOf 3 (map read $ lines contents)
        roadSystem = map (\[a,b,c] -> Section a b c) threes
        path = optimalPath roadSystem
        pathString = concat $ map (show . fst) path
        pathPrice = sum $ map snd path
    putStrLn $ "The best path to take is: " ++ pathString
    putStrLn $ "The price is: " ++ show pathPrice
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
50
10
30
5
90
20
40
2
25
10
8
0
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ cat paths.txt | runhaskell heathrow.hs
The best path to take is: BCACBBC
The price is: 75
		 </code>
 	</pre> 
</div>

</div>

<h1 id="11-functors-applicative-functors-and-monoids"class="text-center font-bold text-4xl my-40">11-functors-applicative-functors-and-monoids</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do line <- getLine
          let line' = reverse line
          putStrLn $ "You said " ++ line' ++ " backwards!"
          putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do line <- fmap reverse getLine
          putStrLn $ "You said " ++ line ++ " backwards!"
          putStrLn $ "Yes, you really said" ++ line ++ " backwards!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.Char
import Data.List

main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine
          putStrLn line
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
$ runhaskell fmapping_io.hs
hello there
E-R-E-H-T- -O-L-L-E-H
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor ((->) r) where
    fmap f g = (\x -> f (g x))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor (r ->) where
    fmap f g = (\x -> f (g x))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor ((->) r) where
    fmap = (.)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t fmap (*3) (+100)
fmap (*3) (+100) :: (Num a) => a -> a
ghci> fmap (*3) (+100) 1
303
ghci> (*3) `fmap` (+100) $ 1
303
ghci> (*3) . (+100) $ 1
303
ghci> fmap (show . (*3)) (*100) 1
"300"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t fmap (*2)
fmap (*2) :: (Num a, Functor f) => f a -> f a
ghci> :t fmap (replicate 3)
fmap (replicate 3) :: (Functor f) => f a -> f [a]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fmap (replicate 3) [1,2,3,4]
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
ghci> fmap (replicate 3) (Just 4)
Just [4,4,4]
ghci> fmap (replicate 3) (Right "blah")
Right ["blah","blah","blah"]
ghci> fmap (replicate 3) Nothing
Nothing
ghci> fmap (replicate 3) (Left "foo")
Left "foo"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fmap id (Just 3)
Just 3
ghci> id (Just 3)
Just 3
ghci> fmap id [1..5]
[1,2,3,4,5]
ghci> id [1..5]
[1,2,3,4,5]
ghci> fmap id []
[]
ghci> fmap id Nothing
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data CMaybe a = CNothing | CJust Int a deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> CNothing
CNothing
ghci> CJust 0 "haha"
CJust 0 "haha"
ghci> :t CNothing
CNothing :: CMaybe a
ghci> :t CJust 0 "haha"
CJust 0 "haha" :: CMaybe [Char]
ghci> CJust 100 [1,2,3]
CJust 100 [1,2,3]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor CMaybe where
    fmap f CNothing = CNothing
    fmap f (CJust counter x) = CJust (counter+1) (f x)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fmap (++"ha") (CJust 0 "ho")
CJust 1 "hoha"
ghci> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))
CJust 2 "hohahe"
ghci> fmap (++"blah") CNothing
CNothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fmap id (CJust 0 "haha")
CJust 1 "haha"
ghci> id (CJust 0 "haha")
CJust 0 "haha"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t fmap (++) (Just "hey")
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])
ghci> :t fmap compare (Just 'a')
fmap compare (Just 'a') :: Maybe (Char -> Ordering)
ghci> :t fmap compare "A LIST OF CHARS"
fmap compare "A LIST OF CHARS" :: [Char -> Ordering]
ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]
fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let a = fmap (*) [1,2,3,4]
ghci> :t a
a :: [Integer -> Integer]
ghci> fmap (\f -> f 9) a
[9,18,27,36]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Applicative Maybe where
    pure = Just
    Nothing <*> _ = Nothing
    (Just f) <*> something = fmap f something
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Just (+3) <*> Just 9
Just 12
ghci> pure (+3) <*> Just 10
Just 13
ghci> pure (+3) <*> Just 9
Just 12
ghci> Just (++"hahah") <*> Nothing
Nothing
ghci> Nothing <*> Just "woot"
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> pure (+) <*> Just 3 <*> Just 5
Just 8
ghci> pure (+) <*> Just 3 <*> Nothing
Nothing
ghci> pure (+) <*> Nothing <*> Just 5
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
(<$>) :: (Functor f) => (a -> b) -> f a -> f b
f <$> x = fmap f x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (++) <$> Just "johntra" <*> Just "volta"
Just "johntravolta"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (++) "johntra" "volta"
"johntravolta"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Applicative [] where
    pure x = [x]
    fs <*> xs = [f x | f <- fs, x <- xs]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> pure "Hey" :: [String]
["Hey"]
ghci> pure "Hey" :: Maybe String
Just "Hey"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [(*0),(+100),(^2)] <*> [1,2,3]
[0,0,0,101,102,103,1,4,9]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [(+),(*)] <*> [1,2] <*> [3,4]
[4,5,5,6,3,4,6,8]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
[16,20,22,40,50,55,80,100,110]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (*) <$> [2,5,10] <*> [8,10,11]
[16,20,22,40,50,55,80,100,110]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
[55,80,100,110]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Applicative IO where
    pure = return
    a <*> b = do
        f <- a
        x <- b
        return (f x)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
myAction :: IO String
myAction = do
    a <- getLine
    b <- getLine
    return $ a ++ b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
myAction :: IO String
myAction = (++) <$> getLine <*> getLine
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
main = do
    a <- (++) <$> getLine <*> getLine
    putStrLn $ "The two lines concatenated turn out to be: " ++ a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Applicative ((->) r) where
    pure x = (\_ -> x)
    f <*> g = \x -> f x (g x)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (pure 3) "blah"
3
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> pure 3 "blah"
3
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t (+) <$> (+3) <*> (*100)
(+) <$> (+3) <*> (*100) :: (Num a) => a -> a
ghci> (+) <$> (+3) <*> (*100) $ 5
508
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
[8.0,10.0,2.5]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Applicative ZipList where
        pure x = ZipList (repeat x)
        ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]
[101,102,103]
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]
[101,102,103]
ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]
[5,3,3,4]
ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"
[('d','c','r'),('o','a','a'),('g','t','t')]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
liftA2 f a b = f <$> a <*> b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fmap (\x -> [x]) (Just 4)
Just [4]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> liftA2 (:) (Just 3) (Just [4])
Just [3,4]
ghci> (:) <$> Just 3 <*> Just [4]
Just [3,4]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
sequenceA :: (Applicative f) => [f a] -> f [a]
sequenceA [] = pure []
sequenceA (x:xs) = (:) <$> x <*> sequenceA xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
sequenceA :: (Applicative f) => [f a] -> f [a]
sequenceA = foldr (liftA2 (:)) (pure [])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sequenceA [Just 3, Just 2, Just 1]
Just [3,2,1]
ghci> sequenceA [Just 3, Nothing, Just 1]
Nothing
ghci> sequenceA [(+3),(+2),(+1)] 3
[6,5,4]
ghci> sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]
[]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> map (\f -> f 7) [(>4),(<10),odd]
[True,True,True]
ghci> and $ map (\f -> f 7) [(>4),(<10),odd]
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sequenceA [(>4),(<10),odd] 7
[True,True,True]
ghci> and $ sequenceA [(>4),(<10),odd] 7
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci> sequenceA [[1,2],[3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci> [[x,y] | x <- [1,2], y <- [3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci> sequenceA [[1,2],[3,4],[5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
ghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> sequenceA [getLine, getLine, getLine]
heyh
ho
woo
["heyh","ho","woo"]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [(+1),(*100),(*5)] <*> [1,2,3]
[2,3,4,100,200,300,5,10,15]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getZipList $ ZipList [(+1),(*100),(*5)] <*> ZipList [1,2,3]
[2,200,15]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data ZipList a = ZipList [a]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data ZipList a = ZipList { getZipList :: [a] }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype ZipList a = ZipList { getZipList :: [a] }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Profession = Fighter | Archer | Accountant

data Race = Human | Elf | Orc | Goblin

data PlayerCharacter = PlayerCharacter Race Profession
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> CharList "this will be shown!"
CharList {getCharList = "this will be shown!"}
ghci> CharList "benny" == CharList "benny"
True
ghci> CharList "benny" == CharList "oisters"
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
CharList :: [Char] -> CharList
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
getCharList :: CharList -> [Char]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Functor f where
    fmap :: (a -> b) -> f a -> f b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor Maybe where
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fmap :: (a -> b) -> Maybe a -> Maybe b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype Pair b a = Pair { getPair :: (a,b) }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor (Pair c) where
    fmap f (Pair (x,y)) = Pair (f x, y)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fmap :: (a -> b) -> Pair c a -> Pair c b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Functor f where
    fmap :: (a -> b) -> f a -> f b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getPair $ fmap (*100) (Pair (2,3))
(200,3)
ghci> getPair $ fmap reverse (Pair ("london calling", 3))
("gnillac nodnol",3)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> undefined
*** Exception: Prelude.undefined
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> head [3,4,5,undefined,2,undefined]
3
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data CoolBool = CoolBool { getCoolBool :: Bool }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
helloMe :: CoolBool -> String
helloMe (CoolBool _) = "hello"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> helloMe undefined
"*** Exception: Prelude.undefined
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype CoolBool = CoolBool { getCoolBool :: Bool }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> helloMe undefined
"hello"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type IntList = [Int]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> ([1,2,3] :: IntList) ++ ([1,2,3] :: [Int])
[1,2,3,1,2,3]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype CharList = CharList { getCharList :: [Char] }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 4 * 1
4
ghci> 1 * 9
9
ghci> [1,2,3] ++ []
[1,2,3]
ghci> [] ++ [0.5, 2.5]
[0.5,2.5]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (3 * 2) * (8 * 5)
240
ghci> 3 * (2 * (8 * 5))
240
ghci> "la" ++ ("di" ++ "da")
"ladida"
ghci> ("la" ++ "di") ++ "da"
"ladida"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Monoid m where
    mempty :: m
    mappend :: m -> m -> m
    mconcat :: [m] -> m
    mconcat = foldr mappend mempty
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monoid [a] where
    mempty = []
    mappend = (++)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]
ghci> ("one" `mappend` "two") `mappend` "tree"
"onetwotree"
ghci> "one" `mappend` ("two" `mappend` "tree")
"onetwotree"
ghci> "one" `mappend` "two" `mappend` "tree"
"onetwotree"
ghci> "pang" `mappend` mempty
"pang"
ghci> mconcat [[1,2],[3,6],[9]]
[1,2,3,6,9]
ghci> mempty :: [a]
[]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> "one" `mappend` "two"
"onetwo"
ghci> "two" `mappend` "one"
"twoone"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 0 + 4
4
ghci> 5 + 0
5
ghci> (1 + 3) + 5
9
ghci> 1 + (3 + 5)
9
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype Product a =  Product { getProduct :: a }
    deriving (Eq, Ord, Read, Show, Bounded)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Num a => Monoid (Product a) where
    mempty = Product 1
    Product x `mappend` Product y = Product (x * y)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getProduct $ Product 3 `mappend` Product 9
27
ghci> getProduct $ Product 3 `mappend` mempty
3
ghci> getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2
24
ghci> getProduct . mconcat . map Product $ [3,4,2]
24
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getSum $ Sum 2 `mappend` Sum 9
11
ghci> getSum $ mempty `mappend` Sum 3
3
ghci> getSum . mconcat . map Sum $ [1,2,3]
6
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype Any = Any { getAny :: Bool }
    deriving (Eq, Ord, Read, Show, Bounded)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monoid Any where
        mempty = Any False
        Any x `mappend` Any y = Any (x || y)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getAny $ Any True `mappend` Any False
True
ghci> getAny $ mempty `mappend` Any True
True
ghci> getAny . mconcat . map Any $ [False, False, False, True]
True
ghci> getAny $ mempty `mappend` mempty
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype All = All { getAll :: Bool }
        deriving (Eq, Ord, Read, Show, Bounded)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monoid All where
        mempty = All True
        All x `mappend` All y = All (x && y)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getAll $ mempty `mappend` All True
True
ghci> getAll $ mempty `mappend` All False
False
ghci> getAll . mconcat . map All $ [True, True, True]
True
ghci> getAll . mconcat . map All $ [True, True, False]
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 1 `compare` 2
LT
ghci> 2 `compare` 2
EQ
ghci> 3 `compare` 2
GT
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monoid Ordering where
    mempty = EQ
    LT `mappend` _ = LT
    EQ `mappend` y = y
    GT `mappend` _ = GT
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> LT `mappend` GT
LT
ghci> GT `mappend` LT
GT
ghci> mempty `mappend` LT
LT
ghci> mempty `mappend` GT
GT
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
lengthCompare :: String -> String -> Ordering
lengthCompare x y = let a = length x `compare` length y
                        b = x `compare` y
                    in  if a == EQ then b else a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.Monoid

lengthCompare :: String -> String -> Ordering
lengthCompare x y = (length x `compare` length y) `mappend`
                    (x `compare` y)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> lengthCompare "zen" "ants"
LT
ghci> lengthCompare "zen" "ant"
GT
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.Monoid

lengthCompare :: String -> String -> Ordering
lengthCompare x y = (length x `compare` length y) `mappend`
                    (vowels x `compare` vowels y) `mappend`
                    (x `compare` y)
    where vowels = length . filter (`elem` "aeiou")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> lengthCompare "zen" "anna"
LT
ghci> lengthCompare "zen" "ana"
LT
ghci> lengthCompare "zen" "ann"
GT
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monoid a => Monoid (Maybe a) where
    mempty = Nothing
    Nothing `mappend` m = m
    m `mappend` Nothing = m
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Nothing `mappend` Just "andy"
Just "andy"
ghci> Just LT `mappend` Nothing
Just LT
ghci> Just (Sum 3) `mappend` Just (Sum 4)
Just (Sum {getSum = 7})
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype First a = First { getFirst :: Maybe a }
    deriving (Eq, Ord, Read, Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monoid (First a) where
    mempty = First Nothing
    First (Just x) `mappend` _ = First (Just x)
    First Nothing `mappend` x = x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getFirst $ First (Just 'a') `mappend` First (Just 'b')
Just 'a'
ghci> getFirst $ First Nothing `mappend` First (Just 'b')
Just 'b'
ghci> getFirst $ First (Just 'a') `mappend` First Nothing
Just 'a'
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]
Just 9
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]
Just 10
ghci> getLast $ Last (Just "one") `mappend` Last (Just "two")
Just "two"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import qualified Foldable as F
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t foldr
foldr :: (a -> b -> b) -> b -> [a] -> b
ghci> :t F.foldr
F.foldr :: (F.Foldable t) => (a -> b -> b) -> b -> t a -> b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> foldr (*) 1 [1,2,3]
6
ghci> F.foldr (*) 1 [1,2,3]
6
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> F.foldl (+) 2 (Just 9)
11
ghci> F.foldr (||) False (Just True)
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance F.Foldable Tree where
    foldMap f Empty = mempty
    foldMap f (Node x l r) = F.foldMap f l `mappend`
                             f x           `mappend`
                             F.foldMap f r
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
testTree = Node 5
            (Node 3
                (Node 1 Empty Empty)
                (Node 6 Empty Empty)
            )
            (Node 9
                (Node 8 Empty Empty)
                (Node 10 Empty Empty)
            )
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> F.foldl (+) 0 testTree
42
ghci> F.foldl (*) 1 testTree
64800
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getAny $ F.foldMap (\x -> Any $ x == 3) testTree
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getAny $ F.foldMap (\x -> Any $ x > 15) testTree
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> F.foldMap (\x -> [x]) testTree
[1,3,6,5,8,9,10]
		 </code>
 	</pre> 
</div>

</div>

<h1 id="12-a-fistful-of-monads"class="text-center font-bold text-4xl my-40">12-a-fistful-of-monads</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fmap :: (Functor f) => (a -> b) -> f a -> f b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (*) <$> Just 2 <*> Just 8
Just 16
ghci> (++) <$> Just "klingon" <*> Nothing
Nothing
ghci> (-) <$> [3,4] <*> [1,2,3]
[2,1,0,3,2,1]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
(>>=) :: (Monad m) => m a -> (a -> m b) -> m b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fmap (++"!") (Just "wisdom")
Just "wisdom!"
ghci> fmap (++"!") Nothing
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Just (+3) <*> Just 3
Just 6
ghci> Nothing <*> Just "greed"
Nothing
ghci> Just ord <*> Nothing
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> max <$> Just 3 <*> Just 6
Just 6
ghci> max <$> Just 3 <*> Nothing
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (\x -> Just (x+1)) 1
Just 2
ghci> (\x -> Just (x+1)) 100
Just 101
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b
applyMaybe Nothing f  = Nothing
applyMaybe (Just x) f = f x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Just 3 `applyMaybe` \x -> Just (x+1)
Just 4
ghci> Just "smile" `applyMaybe` \x -> Just (x ++ " :)")
Just "smile :)"
ghci> Nothing `applyMaybe` \x -> Just (x+1)
Nothing
ghci> Nothing `applyMaybe` \x -> Just (x ++ " :)")
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Just 3 `applyMaybe` \x -> if x > 2 then Just x else Nothing
Just 3
ghci> Just 1 `applyMaybe` \x -> if x > 2 then Just x else Nothing
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Monad m where
    return :: a -> m a

    (>>=) :: m a -> (a -> m b) -> m b

    (>>) :: m a -> m b -> m b
    x >> y = x >>= \_ -> y

    fail :: String -> m a
    fail msg = error msg
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monad Maybe where
    return x = Just x
    Nothing >>= f = Nothing
    Just x >>= f  = f x
    fail _ = Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> return "WHAT" :: Maybe String
Just "WHAT"
ghci> Just 9 >>= \x -> return (x*10)
Just 90
ghci> Nothing >>= \x -> return (x*10)
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type Birds = Int
type Pole = (Birds,Birds)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
landLeft :: Birds -> Pole -> Pole
landLeft n (left,right) = (left + n,right)

landRight :: Birds -> Pole -> Pole
landRight n (left,right) = (left,right + n)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> landLeft 2 (0,0)
(2,0)
ghci> landRight 1 (1,2)
(1,3)
ghci> landRight (-1) (1,2)
(1,1)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> landLeft 2 (landRight 1 (landLeft 1 (0,0)))
(3,1)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
x -: f = f x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 100 -: (*3)
300
ghci> True -: not
False
ghci> (0,0) -: landLeft 2
(2,0)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (0,0) -: landLeft 1 -: landRight 1 -: landLeft 2
(3,1)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> landLeft 10 (0,3)
(10,3)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (0,0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)
(0,2)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
landLeft :: Birds -> Pole -> Maybe Pole
landLeft n (left,right)
    | abs ((left + n) - right) < 4 = Just (left + n, right)
    | otherwise                    = Nothing

landRight :: Birds -> Pole -> Maybe Pole
landRight n (left,right)
    | abs (left - (right + n)) < 4 = Just (left, right + n)
    | otherwise                    = Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> landLeft 2 (0,0)
Just (2,0)
ghci> landLeft 10 (0,3)
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> landRight 1 (0,0) >>= landLeft 2
Just (2,1)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Nothing >>= landLeft 2
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2
Just (2,4)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (0,0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)
(0,2)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> return (0,0) >>= landLeft 1 >>= landRight 4 >>= landLeft (-1) >>= landRight (-2)
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
banana :: Pole -> Maybe Pole
banana _ = Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> return (0,0) >>= landLeft 1 >>= banana >>= landRight 1
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
(>>) :: (Monad m) => m a -> m b -> m b
m >> n = m >>= \_ -> n
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Nothing >> Just 3
Nothing
ghci> Just 3 >> Just 4
Just 4
ghci> Just 3 >> Nothing
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> return (0,0) >>= landLeft 1 >> Nothing >>= landRight 1
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
routine :: Maybe Pole
routine = case landLeft 1 (0,0) of
    Nothing -> Nothing
    Just pole1 -> case landRight 4 pole1 of
        Nothing -> Nothing
        Just pole2 -> case landLeft 2 pole2 of
            Nothing -> Nothing
            Just pole3 -> landLeft 1 pole3
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Just 3 >>= (\x -> Just (show x ++ "!"))
Just "3!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))
Just "3!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let x = 3; y = "!" in show x ++ y
"3!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Nothing >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))
Nothing
ghci> Just 3 >>= (\x -> Nothing >>= (\y -> Just (show x ++ y)))
Nothing
ghci> Just 3 >>= (\x -> Just "!" >>= (\y -> Nothing))
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
foo :: Maybe String
foo = Just 3   >>= (\x ->
      Just "!" >>= (\y ->
      Just (show x ++ y)))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
foo :: Maybe String
foo = do
    x <- Just 3
    y <- Just "!"
    Just (show x ++ y)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Just 9 >>= (\x -> Just (x > 8))
Just True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
marySue :: Maybe Bool
marySue = do
    x <- Just 9
    Just (x > 8)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
routine :: Maybe Pole
routine = do
    start <- return (0,0)
    first <- landLeft 2 start
    second <- landRight 2 first
    landLeft 1 second
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> routine
Just (3,2)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
routine :: Maybe Pole
routine =
    case Just (0,0) of
        Nothing -> Nothing
        Just start -> case landLeft 2 start of
            Nothing -> Nothing
            Just first -> case landRight 2 first of
                Nothing -> Nothing
                Just second -> landLeft 1 second
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
routine :: Maybe Pole
routine = do
    start <- return (0,0)
    first <- landLeft 2 start
    Nothing
    second <- landRight 2 first
    landLeft 1 second
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
justH :: Maybe Char
justH = do
    (x:xs) <- Just "hello"
    return x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fail :: (Monad m) => String -> m a
fail msg = error msg
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fail _ = Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
wopwop :: Maybe Char
wopwop = do
    (x:xs) <- Just ""
    return x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> wopwop
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (*) <$> [1,2,3] <*> [10,100,1000]
[10,100,1000,20,200,2000,30,300,3000]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monad [] where
    return x = [x]
    xs >>= f = concat (map f xs)
    fail _ = []
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [3,4,5] >>= \x -> [x,-x]
[3,-3,4,-4,5,-5]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
[[3,-3],[4,-4],[5,-5]]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [] >>= \x -> ["bad","mad","rad"]
[]
ghci> [1,2,3] >>= \x -> []
[]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
listOfTuples :: [(Int,Char)]
listOfTuples = do
    n <- [1,2]
    ch <- ['a','b']
    return (n,ch)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [ (n,ch) | n <- [1,2], ch <- ['a','b'] ]
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [ x | x <- [1..50], '7' `elem` show x ]
[7,17,27,37,47]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
class Monad m => MonadPlus m where
    mzero :: m a
    mplus :: m a -> m a -> m a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance MonadPlus [] where
    mzero = []
    mplus = (++)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
guard :: (MonadPlus m) => Bool -> m ()
guard True = return ()
guard False = mzero
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> guard (5 > 2) :: Maybe ()
Just ()
ghci> guard (1 > 2) :: Maybe ()
Nothing
ghci> guard (5 > 2) :: [()]
[()]
ghci> guard (1 > 2) :: [()]
[]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
[7,17,27,37,47]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> guard (5 > 2) >> return "cool" :: [String]
["cool"]
ghci> guard (1 > 2) >> return "cool" :: [String]
[]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
sevensOnly :: [Int]
sevensOnly = do
    x <- [1..50]
    guard ('7' `elem` show x)
    return x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [ x | x <- [1..50], '7' `elem` show x ]
[7,17,27,37,47]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type KnightPos = (Int,Int)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
moveKnight :: KnightPos -> [KnightPos]
moveKnight (c,r) = do
    (c',r') <- [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)
               ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)
               ]
    guard (c' `elem` [1..8] && r' `elem` [1..8])
    return (c',r')
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
moveKnight :: KnightPos -> [KnightPos]
moveKnight (c,r) = filter onBoard
    [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)
    ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)
    ]
    where onBoard (c,r) = c `elem` [1..8] && r `elem` [1..8]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> moveKnight (6,2)
[(8,1),(8,3),(4,1),(4,3),(7,4),(5,4)]
ghci> moveKnight (8,1)
[(6,2),(7,3)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
in3 :: KnightPos -> [KnightPos]
in3 start = do
    first <- moveKnight start
    second <- moveKnight first
    moveKnight second
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
in3 start = return start >>= moveKnight >>= moveKnight >>= moveKnight
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
canReachIn3 :: KnightPos -> KnightPos -> Bool
canReachIn3 start end = end `elem` in3 start
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (6,2) `canReachIn3` (6,1)
True
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (6,2) `canReachIn3` (7,3)
False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> return 3 >>= (\x -> Just (x+100000))
Just 100003
ghci> (\x -> Just (x+100000)) 3
Just 100003
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> return "WoM" >>= (\x -> [x,x,x])
["WoM","WoM","WoM"]
ghci> (\x -> [x,x,x]) "WoM"
["WoM","WoM","WoM"]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Just "move on up" >>= (\x -> return x)
Just "move on up"
ghci> [1,2,3,4] >>= (\x -> return x)
[1,2,3,4]
ghci> putStrLn "Wah!" >>= (\x -> return x)
Wah!
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
xs >>= f = concat (map f xs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2
Just (2,4)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> ((return (0,0) >>= landRight 2) >>= landLeft 2) >>= landRight 2
Just (2,4)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
return (0,0) >>= (\x ->
landRight 2 x >>= (\y ->
landLeft 2 y >>= (\z ->
landRight 2 z)))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
(.) :: (b -> c) -> (a -> b) -> (a -> c)
f . g = (\x -> f (g x))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
(<=<) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)
f <=< g = (\x -> g x >>= f)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let f x = [x,-x]
ghci> let g x = [x*3,x*2]
ghci> let h = f <=< g
ghci> h 3
[9,-9,6,-6]
		 </code>
 	</pre> 
</div>

</div>

<h1 id="13-for-a-few-monads-more"class="text-center font-bold text-4xl my-40">13-for-a-few-monads-more</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
isBigGang :: Int -> Bool
isBigGang x = x > 9
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
isBigGang :: Int -> (Bool, String)
isBigGang x = (x > 9, "Compared gang size to 9.")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> isBigGang 3
(False,"Compared gang size to 9.")
ghci> isBigGang 30
(True,"Compared gang size to 9.")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
applyLog :: (a,String) -> (a -> (b,String)) -> (b,String)
applyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (3, "Smallish gang.") `applyLog` isBigGang
(False,"Smallish gang.Compared gang size to 9")
ghci> (30, "A freaking platoon.") `applyLog` isBigGang
(True,"A freaking platoon.Compared gang size to 9")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> ("Tobin","Got outlaw name.") `applyLog` (\x -> (length x, "Applied length."))
(5,"Got outlaw name.Applied length.")
ghci> ("Bathcat","Got outlaw name.") `applyLog` (\x -> (length x, "Applied length"))
(7,"Got outlaw name.Applied length")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
applyLog :: (a,[c]) -> (a -> (b,[c])) -> (b,[c])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]
ghci> B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]
Chunk "chi" (Chunk "huahua" Empty)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
applyLog :: (Monoid m) => (a,m) -> (a -> (b,m)) -> (b,m)
applyLog (x,log) f = let (y,newLog) = f x in (y,log `mappend` newLog)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.Monoid

type Food = String
type Price = Sum Int

addDrink :: Food -> (Food,Price)
addDrink "beans" = ("milk", Sum 25)
addDrink "jerky" = ("whiskey", Sum 99)
addDrink _ = ("beer", Sum 30)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Sum 3 `mappend` Sum 9
Sum {getSum = 12}
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> ("beans", Sum 10) `applyLog` addDrink
("milk",Sum {getSum = 35})
ghci> ("jerky", Sum 25) `applyLog` addDrink
("whiskey",Sum {getSum = 124})
ghci> ("dogmeat", Sum 5) `applyLog` addDrink
("beer",Sum {getSum = 35})
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> ("dogmeat", Sum 5) `applyLog` addDrink `applyLog` addDrink
("beer",Sum {getSum = 65})
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype Writer w a = Writer { runWriter :: (a, w) }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance (Monoid w) => Monad (Writer w) where
    return x = Writer (x, mempty)
    (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> runWriter (return 3 :: Writer String Int)
(3,"")
ghci> runWriter (return 3 :: Writer (Sum Int) Int)
(3,Sum {getSum = 0})
ghci> runWriter (return 3 :: Writer (Product Int) Int)
(3,Product {getProduct = 1})
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad.Writer

logNumber :: Int -> Writer [String] Int
logNumber x = Writer (x, ["Got number: " ++ show x])

multWithLog :: Writer [String] Int
multWithLog = do
    a <- logNumber 3
    b <- logNumber 5
    return (a*b)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> runWriter multWithLog
(15,["Got number: 3","Got number: 5"])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
multWithLog :: Writer [String] Int
multWithLog = do
    a <- logNumber 3
    b <- logNumber 5
    tell ["Gonna multiply these two"]
    return (a*b)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> runWriter multWithLog
(15,["Got number: 3","Got number: 5","Gonna multiply these two"])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
gcd' :: Int -> Int -> Int
gcd' a b
    | b == 0    = a
    | otherwise = gcd' b (a `mod` b)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> gcd' 8 3
1
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
gcd' :: Int -> Int -> Writer [String] Int
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad.Writer

gcd' :: Int -> Int -> Writer [String] Int
gcd' a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        gcd' b (a `mod` b)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
Writer (a, ["Finished with " ++ show a])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fst $ runWriter (gcd' 8 3)
1
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> mapM_ putStrLn $ snd $ runWriter (gcd' 8 3)
8 mod 3 = 2
3 mod 2 = 1
2 mod 1 = 0
Finished with 1
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
a ++ (b ++ (c ++ (d ++ (e ++ f))))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
((((a ++ b) ++ c) ++ d) ++ e) ++ f
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad.Writer

gcdReverse :: Int -> Int -> Writer [String] Int
gcdReverse a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        result <- gcdReverse b (a `mod` b)
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        return result
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> mapM_ putStrLn $ snd $ runWriter (gcdReverse 8 3)
Finished with 1
2 mod 1 = 0
3 mod 2 = 1
8 mod 3 = 2
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
f `append` g = \xs -> f (g xs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
\xs -> "dog" ++ ("meat" ++ xs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype DiffList a = DiffList { getDiffList :: [a] -> [a] }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
toDiffList :: [a] -> DiffList a
toDiffList xs = DiffList (xs++)

fromDiffList :: DiffList a -> [a]
fromDiffList (DiffList f) = f []
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monoid (DiffList a) where
    mempty = DiffList (\xs -> [] ++ xs)
    (DiffList f) `mappend` (DiffList g) = DiffList (\xs -> f (g xs))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
[1,2,3,4,1,2,3]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad.Writer

gcd' :: Int -> Int -> Writer (DiffList String) Int
gcd' a b
    | b == 0 = do
        tell (toDiffList ["Finished with " ++ show a])
        return a
    | otherwise = do
        result <- gcd' b (a `mod` b)
        tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
        return result
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> mapM_ putStrLn . fromDiffList . snd . runWriter $ gcdReverse 110 34
Finished with 2
8 mod 2 = 0
34 mod 8 = 2
110 mod 34 = 8
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
finalCountDown :: Int -> Writer (DiffList String) ()
finalCountDown 0 = do
    tell (toDiffList ["0"])
finalCountDown x = do
    finalCountDown (x-1)
    tell (toDiffList [show x])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> mapM_ putStrLn . fromDiffList . snd . runWriter $ finalCountDown 500000
0
1
2
...
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
finalCountDown :: Int -> Writer [String] ()
finalCountDown 0 = do
    tell ["0"]
finalCountDown x = do
    finalCountDown (x-1)
    tell [show x]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> mapM_ putStrLn . snd . runWriter $ finalCountDown 500000
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let f = (*5)
ghci> let g = (+3)
ghci> (fmap f g) 8
55
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let f = (+) <$> (*2) <*> (+10)
ghci> f 3
19
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monad ((->) r) where
    return x = \_ -> x
    h >>= f = \w -> f (h w) w
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad.Instances

addStuff :: Int -> Int
addStuff = do
    a <- (*2)
    b <- (+10)
    return (a+b)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> addStuff 3
19
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
addStuff :: Int -> Int
addStuff x = let
    a = (*2) x
    b = (+10) x
    in a+b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
threeCoins :: StdGen -> (Bool, Bool, Bool)
threeCoins gen =
    let (firstCoin, newGen) = random gen
        (secondCoin, newGen') = random newGen
        (thirdCoin, newGen'') = random newGen'
    in  (firstCoin, secondCoin, thirdCoin)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
s -> (a,s)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type Stack = [Int]

pop :: Stack -> (Int,Stack)
pop (x:xs) = (x,xs)

push :: Int -> Stack -> ((),Stack)
push a xs = ((),a:xs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
stackManip :: Stack -> (Int, Stack)
stackManip stack = let
    ((),newStack1) = push 3 stack
    (a ,newStack2) = pop newStack1
    in pop newStack2
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> stackManip [5,8,2,1]
(5,[8,2,1])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
stackManip = do
    push 3
    a <- pop
    pop
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
newtype State s a = State { runState :: s -> (a,s) }
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monad (State s) where
    return x = State $ \s -> (x,s)
    (State h) >>= f = State $ \s -> let (a, newState) = h s
                                        (State g) = f a
                                    in  g newState
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad.State

pop :: State Stack Int
pop = State $ \(x:xs) -> (x,xs)

push :: Int -> State Stack ()
push a = State $ \xs -> ((),a:xs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Control.Monad.State

stackManip :: State Stack Int
stackManip = do
    push 3
    a <- pop
    pop
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> runState stackManip [5,8,2,1]
(5,[8,2,1])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
stackManip :: State Stack Int
stackManip = do
    push 3
    pop
    pop
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
stackStuff :: State Stack ()
stackStuff = do
    a <- pop
    if a == 5
        then push 5
        else do
            push 3
            push 8
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> runState stackStuff [9,0,2,1,0]
((),[8,3,0,2,1,0])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
moreStack :: State Stack ()
moreStack = do
    a <- stackManip
    if a == 100
        then stackStuff
        else return ()
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
get = State $ \s -> (s,s)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
put newState = State $ \s -> ((),newState)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
stackyStack :: State Stack ()
stackyStack = do
    stackNow <- get
    if stackNow == [1,2,3]
        then put [8,3,1]
        else put [9,2,1]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
(>>=) :: State s a -> (a -> State s b) -> State s b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
random :: (RandomGen g, Random a) => g -> (a, g)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Random
import Control.Monad.State

randomSt :: (RandomGen g, Random a) => State g a
randomSt = State random
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import System.Random
import Control.Monad.State

threeCoins :: State StdGen (Bool,Bool,Bool)
threeCoins = do
    a <- randomSt
    b <- randomSt
    c <- randomSt
    return (a,b,c)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> runState threeCoins (mkStdGen 33)
((True,False,True),680029187 2103410263)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t Right 4
Right 4 :: (Num t) => Either a t
ghci> :t Left "out of cheese error"
Left "out of cheese error" :: Either [Char] b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance (Error e) => Monad (Either e) where
    return x = Right x
    Right x >>= f = f x
    Left err >>= f = Left err
    fail msg = Left (strMsg msg)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> :t strMsg
strMsg :: (Error a) => String -> a
ghci> strMsg "boom!" :: String
"boom!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Left "boom" >>= \x -> return (x+1)
Left "boom"
ghci> Right 100 >>= \x -> Left "no way!"
Left "no way!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Right 3 >>= \x -> return (x + 100)

<interactive>:1:0:
    Ambiguous type variable `a' in the constraints:
      `Error a' arising from a use of `it' at <interactive>:1:0-33
      `Show a' arising from a use of `print' at <interactive>:1:0-33
    Probable fix: add a type signature that fixes these type variable(s)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Right 3 >>= \x -> return (x + 100) :: Either String Int
Right 103
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
liftM :: (Monad m) => (a -> b) -> m a -> m b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fmap :: (Functor f) => (a -> b) -> f a -> f b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> liftM (*3) (Just 8)
Just 24
ghci> fmap (*3) (Just 8)
Just 24
ghci> runWriter $ liftM not $ Writer (True, "chickpeas")
(False,"chickpeas")
ghci> runWriter $ fmap not $ Writer (True, "chickpeas")
(False,"chickpeas")
ghci> runState (liftM (+100) pop) [1,2,3,4]
(101,[2,3,4])
ghci> runState (fmap (+100) pop) [1,2,3,4]
(101,[2,3,4])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
liftM :: (Monad m) => (a -> b) -> m a -> m b
liftM f m = m >>= (\x -> return (f x))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
liftM :: (Monad m) => (a -> b) -> m a -> m b
liftM f m = do
    x <- m
    return (f x)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (+) <$> Just 3 <*> Just 5
Just 8
ghci> (+) <$> Just 3 <*> Nothing
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ap :: (Monad m) => m (a -> b) -> m a -> m b
ap mf m = do
    f <- mf
    x <- m
    return (f x)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> Just (+3) <*> Just 4
Just 7
ghci> Just (+3) `ap` Just 4
Just 7
ghci> [(+1),(+2),(+3)] <*> [10,11]
[11,12,12,13,13,14]
ghci> [(+1),(+2),(+3)] `ap` [10,11]
[11,12,12,13,13,14]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
liftA2 f x y = f <$> x <*> y
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
join :: (Monad m) => m (m a) -> m a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> join (Just (Just 9))
Just 9
ghci> join (Just Nothing)
Nothing
ghci> join Nothing
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> join [[1,2,3],[4,5,6]]
[1,2,3,4,5,6]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> runWriter $ join (Writer (Writer (1,"aaa"),"bbb"))
(1,"bbbaaa")
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> join (Right (Right 9)) :: Either String Int
Right 9
ghci> join (Right (Left "error")) :: Either String Int
Left "error"
ghci> join (Left "error") :: Either String Int
Left "error"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> runState (join (State $ \s -> (push 10,1:2:s))) [0,0,0]
((),[10,1,2,0,0,0])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
join :: (Monad m) => m (m a) -> m a
join mm = do
    m <- mm
    m
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
joinedMaybes :: Maybe Int
joinedMaybes = do
    m <- Just (Just 8)
    m
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
filter :: (a -> Bool) -> [a] -> [a]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> filter (\x -> x < 4) [9,1,5,2,10,3]
[1,2,3]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
keepSmall :: Int -> Writer [String] Bool
keepSmall x
    | x < 4 = do
        tell ["Keeping " ++ show x]
        return True
    | otherwise = do
        tell [show x ++ " is too large, throwing it away"]
        return False
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fst $ runWriter $ filterM keepSmall [9,1,5,2,10,3]
[1,2,3]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> mapM_ putStrLn $ snd $ runWriter $ filterM keepSmall [9,1,5,2,10,3]
9 is too large, throwing it away
Keeping 1
5 is too large, throwing it away
Keeping 2
10 is too large, throwing it away
Keeping 3
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
[1,2,3]
[1,2]
[1,3]
[1]
[2,3]
[2]
[3]
[]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
powerset :: [a] -> [[a]]
powerset xs = filterM (\x -> [True, False]) xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> powerset [1,2,3]
[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
foldl :: (a -> b -> a) -> a -> [b] -> a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> foldl (\acc x -> acc + x) 0 [2,8,3,1]
14
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
binSmalls :: Int -> Int -> Maybe Int
binSmalls acc x
    | x > 9     = Nothing
    | otherwise = Just (acc + x)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> foldM binSmalls 0 [2,8,3,1]
Just 14
ghci> foldM binSmalls 0 [2,11,3,1]
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List

solveRPN :: String -> Double
solveRPN = head . foldl foldingFunction [] . words
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
foldingFunction :: [Double] -> String -> [Double]
foldingFunction (x:y:ys) "*" = (x * y):ys
foldingFunction (x:y:ys) "+" = (x + y):ys
foldingFunction (x:y:ys) "-" = (y - x):ys
foldingFunction xs numberString = read numberString:xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
foldingFunction :: [Double] -> String -> Maybe [Double]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
readMaybe :: (Read a) => String -> Maybe a
readMaybe st = case reads st of [(x,"")] -> Just x
                                _ -> Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> readMaybe "1" :: Maybe Int
Just 1
ghci> readMaybe "GO TO HELL" :: Maybe Int
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
foldingFunction :: [Double] -> String -> Maybe [Double]
foldingFunction (x:y:ys) "*" = return ((x * y):ys)
foldingFunction (x:y:ys) "+" = return ((x + y):ys)
foldingFunction (x:y:ys) "-" = return ((y - x):ys)
foldingFunction xs numberString = liftM (:xs) (readMaybe numberString)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> foldingFunction [3,2] "*"
Just [6.0]
ghci> foldingFunction [3,2] "-"
Just [-1.0]
ghci> foldingFunction [] "*"
Nothing
ghci> foldingFunction [] "1"
Just [1.0]
ghci> foldingFunction [] "1 wawawawa"
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List

solveRPN :: String -> Maybe Double
solveRPN st = do
    [result] <- foldM foldingFunction [] (words st)
    return result
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> solveRPN "1 2 * 4 +"
Just 6.0
ghci> solveRPN "1 2 * 4 + 5 *"
Just 30.0
ghci> solveRPN "1 2 * 4"
Nothing
ghci> solveRPN "1 8 wharglbllargh"
Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let f = (+1) . (*100)
ghci> f 4
401
ghci> let g = (\x -> return (x+1)) <=< (\x -> return (x*100))
ghci> Just 4 >>= g
Just 401
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let f = foldr (.) id [(+1),(*100),(+1)]
ghci> f 1
201
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
in3 start = return start >>= moveKnight >>= moveKnight >>= moveKnight
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
canReachIn3 :: KnightPos -> KnightPos -> Bool
canReachIn3 start end = end `elem` in3 start
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List

inMany :: Int -> KnightPos -> [KnightPos]
inMany x start = return start >>= foldr (<=<) return (replicate x moveKnight)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
canReachIn :: Int -> KnightPos -> KnightPos -> Bool
canReachIn x start end = end `elem` inMany x start
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
[(3,0.5),(5,0.25),(9,0.25)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> 1%4
1 % 4
ghci> 1%2 + 1%2
1 % 1
ghci> 1%3 + 5%4
19 % 12
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> [(3,1%2),(5,1%4),(9,1%4)]
[(3,1 % 2),(5,1 % 4),(9,1 % 4)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.Ratio

newtype Prob a = Prob { getProb :: [(a,Rational)] } deriving Show
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Functor Prob where
    fmap f (Prob xs) = Prob $ map (\(x,p) -> (f x,p)) xs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fmap negate (Prob [(3,1%2),(5,1%4),(9,1%4)])
Prob {getProb = [(-3,1 % 2),(-5,1 % 4),(-9,1 % 4)]}
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
thisSituation :: Prob (Prob Char)
thisSituation = Prob
    [( Prob [('a',1%2),('b',1%2)] , 1%4 )
    ,( Prob [('c',1%2),('d',1%2)] , 3%4)
    ]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
flatten :: Prob (Prob a) -> Prob a
flatten (Prob xs) = Prob $ concat $ map multAll xs
    where multAll (Prob innerxs,p) = map (\(x,r) -> (x,p*r)) innerxs
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
instance Monad Prob where
    return x = Prob [(x,1%1)]
    m >>= f = flatten (fmap f m)
    fail _ = Prob []
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Coin = Heads | Tails deriving (Show, Eq)

coin :: Prob Coin
coin = Prob [(Heads,1%2),(Tails,1%2)]

loadedCoin :: Prob Coin
loadedCoin = Prob [(Heads,1%10),(Tails,9%10)]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List (all)

flipThree :: Prob Bool
flipThree = do
    a <- coin
    b <- coin
    c <- loadedCoin
    return (all (==Tails) [a,b,c])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> getProb flipThree
[(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),
 (False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]
		 </code>
 	</pre> 
</div>

</div>

<h1 id="14-zippers"class="text-center font-bold text-4xl my-40">14-zippers</h1>
  <div class="flex flex-row flex-wrap">
<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
freeTree :: Tree Char
freeTree =
    Node 'P'
        (Node 'O'
            (Node 'L'
                (Node 'N' Empty Empty)
                (Node 'T' Empty Empty)
            )
            (Node 'Y'
                (Node 'S' Empty Empty)
                (Node 'A' Empty Empty)
            )
        )
        (Node 'L'
            (Node 'W'
                (Node 'C' Empty Empty)
                (Node 'R' Empty Empty)
            )
            (Node 'A'
                (Node 'A' Empty Empty)
                (Node 'C' Empty Empty)
            )
        )
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
changeToP :: Tree Char -> Tree Char
changeToP (Node x l (Node y (Node _ m n) r)) = Node x l (Node y (Node 'P' m n) r)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Direction = L | R deriving (Show)
type Directions = [Direction]

changeToP :: Directions-> Tree Char -> Tree Char
changeToP (L:ds) (Node x l r) = Node x (changeToP ds l) r
changeToP (R:ds) (Node x l r) = Node x l (changeToP ds r)
changeToP [] (Node _ l r) = Node 'P' l r
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
elemAt :: Directions -> Tree a -> a
elemAt (L:ds) (Node _ l _) = elemAt ds l
elemAt (R:ds) (Node _ _ r) = elemAt ds r
elemAt [] (Node x _ _) = x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let newTree = changeToP [R,L] freeTree
ghci> elemAt [R,L] newTree
'P'
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type Breadcrumbs = [Direction]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
goLeft :: (Tree a, Breadcrumbs) -> (Tree a, Breadcrumbs)
goLeft (Node _ l _, bs) = (l, L:bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
goRight :: (Tree a, Breadcrumbs) -> (Tree a, Breadcrumbs)
goRight (Node _ _ r, bs) = (r, R:bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> goLeft (goRight (freeTree, []))
(Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
x -: f = f x
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> (freeTree, []) -: goRight -: goLeft
(Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data Crumb a = LeftCrumb a (Tree a) | RightCrumb a (Tree a) deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type Breadcrumbs a = [Crumb a]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
goLeft :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)
goLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
goRight :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)
goRight (Node x l r, bs) = (r, RightCrumb x l:bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
goUp :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)
goUp (t, LeftCrumb x r:bs) = (Node x t r, bs)
goUp (t, RightCrumb x l:bs) = (Node x l t, bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type Zipper a = (Tree a, Breadcrumbs a)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
modify :: (a -> a) -> Zipper a -> Zipper a
modify f (Node x l r, bs) = (Node (f x) l r, bs)
modify f (Empty, bs) = (Empty, bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let newFocus = modify (\_ -> 'P') (goRight (goLeft (freeTree,[])))
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let newFocus = (freeTree,[]) -: goLeft -: goRight -: modify (\_ -> 'P')
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let newFocus2 = modify (\_ -> 'X') (goUp newFocus)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let newFocus2 = newFocus -: goUp -: modify (\_ -> 'X')
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
attach :: Tree a -> Zipper a -> Zipper a
attach t (_, bs) = (t, bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let farLeft = (freeTree,[]) -: goLeft -: goLeft -: goLeft -: goLeft
ghci> let newFocus = farLeft -: attach (Node 'Z' Empty Empty)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
topMost :: Zipper a -> Zipper a
topMost (t,[]) = (t,[])
topMost z = topMost (goUp z)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type ListZipper a = ([a],[a])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
goForward :: ListZipper a -> ListZipper a
goForward (x:xs, bs) = (xs, x:bs)

goBack :: ListZipper a -> ListZipper a
goBack (xs, b:bs) = (b:xs, bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let xs = [1,2,3,4]
ghci> goForward (xs,[])
([2,3,4],[1])
ghci> goForward ([2,3,4],[1])
([3,4],[2,1])
ghci> goForward ([3,4],[2,1])
([4],[3,2,1])
ghci> goBack ([4],[3,2,1])
([3,4],[2,1])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type Name = String
type Data = String
data FSItem = File Name Data | Folder Name [FSItem] deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
myDisk :: FSItem
myDisk =
    Folder "root"
        [ File "goat_yelling_like_man.wmv" "baaaaaa"
        , File "pope_time.avi" "god bless"
        , Folder "pics"
            [ File "ape_throwing_up.jpg" "bleargh"
            , File "watermelon_smash.gif" "smash!!"
            , File "skull_man(scary).bmp" "Yikes!"
            ]
        , File "dijon_poupon.doc" "best mustard"
        , Folder "programs"
            [ File "fartwizard.exe" "10gotofart"
            , File "owl_bandit.dmg" "mov eax, h00t"
            , File "not_a_virus.exe" "really not a virus"
            , Folder "source code"
                [ File "best_hs_prog.hs" "main = print (fix error)"
                , File "random.hs" "main = print 4"
                ]
            ]
        ]
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
data FSCrumb = FSCrumb Name [FSItem] [FSItem] deriving (Show)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
type FSZipper = (FSItem, [FSCrumb])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fsUp :: FSZipper -> FSZipper
fsUp (item, FSCrumb name ls rs:bs) = (Folder name (ls ++ [item] ++ rs), bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
import Data.List (break)

fsTo :: Name -> FSZipper -> FSZipper
fsTo name (Folder folderName items, bs) =
    let (ls, item:rs) = break (nameIs name) items
    in  (item, FSCrumb folderName ls rs:bs)

nameIs :: Name -> FSItem -> Bool
nameIs name (Folder folderName _) = name == folderName
nameIs name (File fileName _) = name == fileName
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let newFocus = (myDisk,[]) -: fsTo "pics" -: fsTo "skull_man(scary).bmp"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> fst newFocus
File "skull_man(scary).bmp" "Yikes!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let newFocus2 = newFocus -: fsUp -: fsTo "watermelon_smash.gif"
ghci> fst newFocus2
File "watermelon_smash.gif" "smash!!"
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fsRename :: Name -> FSZipper -> FSZipper
fsRename newName (Folder name items, bs) = (Folder newName items, bs)
fsRename newName (File name dat, bs) = (File newName dat, bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let newFocus = (myDisk,[]) -: fsTo "pics" -: fsRename "cspi" -: fsUp
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
fsNewFile :: FSItem -> FSZipper -> FSZipper
fsNewFile item (Folder folderName items, bs) =
    (Folder folderName (item:items), bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let newFocus = (myDisk,[]) -: fsTo "pics" -: fsNewFile (File "heh.jpg" "lol") -: fsUp
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
goLeft :: Zipper a -> Zipper a
goLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
goLeft :: Zipper a -> Maybe (Zipper a)
goLeft (Node x l r, bs) = Just (l, LeftCrumb x r:bs)
goLeft (Empty, _) = Nothing

goRight :: Zipper a -> Maybe (Zipper a)
goRight (Node x l r, bs) = Just (r, RightCrumb x l:bs)
goRight (Empty, _) = Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> goLeft (Empty, [])
Nothing
ghci> goLeft (Node 'A' Empty Empty, [])
Just (Empty,[LeftCrumb 'A' Empty])
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
goUp :: Zipper a -> Zipper a
goUp (t, LeftCrumb x r:bs) = (Node x t r, bs)
goUp (t, RightCrumb x l:bs) = (Node x l t, bs)
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
goUp :: Zipper a -> Maybe (Zipper a)
goUp (t, LeftCrumb x r:bs) = Just (Node x t r, bs)
goUp (t, RightCrumb x l:bs) = Just (Node x l t, bs)
goUp (_, []) = Nothing
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
gchi> let newFocus = (freeTree,[]) -: goLeft -: goRight
		 </code>
 	</pre> 
</div>

<div class="block rounded border-solid shadow-xl"> 
	<pre>
		<code style ="color:black">
ghci> let coolTree = Node 1 Empty (Node 3 Empty Empty)
ghci> return (coolTree,[]) >>= goRight
Just (Node 3 Empty Empty,[RightCrumb 1 Empty])
ghci> return (coolTree,[]) >>= goRight >>= goRight
Just (Empty,[RightCrumb 3 Empty,RightCrumb 1 Empty])
ghci> return (coolTree,[]) >>= goRight >>= goRight >>= goRight
Nothing
		 </code>
 	</pre> 
</div>

</div></body>
 </html>